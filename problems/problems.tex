\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}

\geometry{left=2cm, right=2cm, top=2cm, bottom=2cm}

% Настройка listings для Java
\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true,
    breakatwhitespace=false,
    tabsize=4,
    captionpos=b
}

\titleformat{\section}{\large\bfseries\centering}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

\title{Задачник по курсу <<Программирование на Java}
\author{Глускер А.И.}
\date{\today}


\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Предварительные сведения}

\subsection*{Требования к качеству кода}
\begin{itemize}
\item \textbf{Инкапсуляция:} Все поля классов должны быть private с 
публичными геттерами/сеттерами только при необходимости
    \item \textbf{Валидация данных:} Обязательная проверка корректности 
    входных данных с оповещением пользователя об ошибках
    \item \textbf{Обработка исключений:} Использование try-catch блоков для обработки 
    возможных ошибок выполнения
    \item \textbf{Документирование:} Javadoc-комментарии для всех классов, 
    методов и нетривиальных полей (начиная с семинара <<ООП>>)
    \item \textbf{Стиль кода:} Соблюдение соглашений об именовании Java 
    (camelCase для методов/переменных, PascalCase для классов)
\end{itemize}

\subsection*{Требования к функциональности}
\begin{itemize}
\item \textbf{Граничные случаи:} Обработка всех возможных граничных ситуаций 
(пустые коллекции, нулевые значения, переполнение)
    \item \textbf{Производительность:} Оптимизация алгоритмов до приемлемой сложности 
    \item \textbf{Тестируемость:} Разделение логики и ввода/вывода для возможности 
    unit-тестирования (начиная с соответствующего семинара)
\end{itemize}

\subsection*{Требования к оформлению}
\begin{itemize}
\item \textbf{Читаемость:} Разумное форматирование кода с отступами и пробелами
    \item \textbf{Минимальная сложность:} Упрощение условий и избегание глубокой
     вложенности
    \item \textbf{Константы вместо магических чисел:} Использование именованных 
    констант для всех значений
    \item \textbf{Разделение ответственности:} Каждый метод должен выполнять 
    одну логическую задачу (начиная с семинара <<ООП>>)
\end{itemize}

\subsection*{Требования к сдаче работ}
\begin{itemize}
    \item Автор должен быть способным объяснить любой фрагмент кода, а также незначительно
    его модифицировать
    \item Автор должен знать теоретический материал, относящийся к работе
\end{itemize}

\section{Семинар №1 <<Введение>>}
На этом занятии вы познакомитесь с основными управляющими конструкциями языка Java: условными операторами (\texttt{if}, \texttt{switch}) и циклами (\texttt{for}, \texttt{while}, \texttt{do\_while}). Каждая тема включает краткое пояснение, пример и набор задач для самостоятельного решения.

% Сюда будем добавлять разделы по мере ваших указаний

\subsection{Условный оператор \texttt{if}}

\subsubsection*{Задачи}

Решите следующие задачи, используя условные операторы \texttt{if}. Обеспечьте полную проверку ввода данных и корректную обработку всех математических случаев (деление на ноль, вырожденные интервалы, отрицательные значения и т.п.).

\begin{enumerate}
    \item Напишите программу, которая решает неравенство $(x - a)(x - b) > 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)(x - b) < 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)(x - b) \geqslant 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)(x - b) \leqslant 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x + a)(x + b) > 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x + a)(x + b) < 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(a - x)(b - x) > 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(a - x)(b - x) < 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)^2 > 0$, где $a$ — вещественное число, вводимое пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)^2 \geqslant 0$, где $a$ — вещественное число, вводимое пользователем.
    \item Напишите программу, которая решает неравенство $\frac{x - a}{x - b} > 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $\frac{x - a}{x - b} < 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $\frac{x - a}{x - b} \geqslant 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $\frac{x - a}{x - b} \leqslant 0$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $|x - a| > b$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $|x - a| < b$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $|x - a| \geqslant b$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $|x - a| \leqslant b$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)(x - b)(x - c) > 0$, где $a$, $b$, $c$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает неравенство $(x - a)(x - b)(x - c) < 0$, где $a$, $b$, $c$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая определяет, принадлежит ли точка $x$ интервалу $(a; b)$, где $a$, $b$, $x$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая определяет, принадлежит ли точка $x$ отрезку $[a; b]$, где $a$, $b$, $x$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая определяет, лежит ли число $x$ вне отрезка $[a; b]$, где $a$, $b$, $x$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает систему неравенств $x > a$ и $x < b$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
    \item Напишите программу, которая решает совокупность неравенств $x < a$ или $x > b$, где $a$ и $b$ — вещественные числа, вводимые пользователем.
\end{enumerate}


\subsection{Оператор \texttt{switch}}

\subsubsection*{Задачи}

Решите следующие задачи, используя оператор \texttt{switch}. Запрещено использовать стандартные классы для работы с датами — дата задаётся тремя целыми числами: день, месяц, год. Обеспечьте полную проверку корректности ввода (существование даты, високосный год, допустимые диапазоны).

\begin{enumerate}
    \item По введённой дате определите дату следующего дня. Выведите её и проверьте, совпадает ли количество дней в месяце исходной даты с количеством дней в месяце полученной даты.
    \item По введённой дате определите дату предыдущего дня. Выведите её и проверьте, совпадает ли количество дней в месяце исходной даты с количеством дней в месяце полученной даты.
    \item По введённой дате определите дату, которая наступит ровно через месяц (прибавить 1 к месяцу, при необходимости корректируя год). Если в следующем месяце нет дня с таким же числом (например, 31 апреля), то возьмите последний день следующего месяца. Выведите полученную дату и проверьте, является ли она последним днём месяца.
    \item По введённой дате определите дату, которая была ровно месяц назад (вычесть 1 из месяца, при необходимости корректируя год). Если в предыдущем месяце нет дня с таким же числом, возьмите последний день предыдущего месяца. Выведите полученную дату и проверьте, является ли она первым днём месяца.
    \item По введённой дате определите дату, которая наступит через 2 месяца (прибавить 2 к месяцу, корректируя год). Корректировка дня, как в предыдущих задачах. Выведите полученную дату и проверьте, находится ли она в том же квартале года, что и исходная дата. (Кварталы: 1-3, 4-6, 7-9, 10-12)
    \item По введённой дате определите дату, которая была 3 месяца назад. Выведите полученную дату и проверьте, находится ли она в том же году, что и исходная дата.
    \item По введённой дате определите дату, которая наступит через 1 год (прибавить 1 к году). Учтите високосность года для февраля. Если исходная дата - 29 февраля, то в следующем невисокосном году возьмите 28 февраля. Выведите полученную дату и проверьте, является ли она високосным днём (29 февраля).
    \item По введённой дате определите дату, которая была 1 год назад. Выведите полученную дату и проверьте, была ли исходная дата високосным днём (29 февраля), а полученная - нет.
    \item По введённой дате определите дату, которая наступит через 100 дней. Выведите её и проверьте, является ли полученная дата последним днём месяца.
    \item По введённой дате определите дату, которая была 100 дней назад. Выведите её и проверьте, является ли полученная дата первым днём месяца.
    \item По введённой дате определите дату, которая наступит через 1 неделю (7 дней). Выведите её и проверьте, находится ли полученная дата в том же месяце, что и исходная.
    \item По введённой дате определите дату, которая была 1 неделю назад. Выведите её и проверьте, находится ли полученная дата в том же году, что и исходная.
    \item По введённой дате определите дату, которая наступит через 2 месяца. Выведите её и проверьте, является ли день полученной даты последним днём месяца.
    \item По введённой дате определите дату, которая была 2 месяца назад. Выведите её и проверьте, является ли день полученной даты первым днём месяца.
    \item По введённой дате определите дату, которая наступит через 6 месяцев. Выведите её и проверьте, находится ли полученная дата во второй половине года (месяц с июля по декабрь).
    \item По введённой дате определите дату, которая была 6 месяцев назад. Выведите её и проверьте, находится ли полученная дата в первом полугодии (месяц с января по июнь).
    \item По введённой дате определите дату, которая наступит через 1 месяц и 1 день (сначала прибавить месяц, затем день). Корректировка дня, как в задаче 3. Выведите полученную дату и проверьте, является ли она первым днём месяца.
    \item По введённой дате определите дату, которая была 1 месяц и 1 день назад (сначала вычесть месяц, затем день). Выведите полученную дату и проверьте, является ли она последним днём месяца.
    \item По введённой дате определите дату, которая наступит через 2 года. Выведите её и проверьте, является ли год полученной даты високосным.
    \item По введённой дате определите дату, которая была 2 года назад. Выведите её и проверьте, был ли год полученной даты високосным.
    \item По введённой дате определите дату, которая наступит через 1 квартал (3 месяца). Выведите её и проверьте, является ли полученная дата последним днём квартала (31 марта, 30 июня, 30 сентября, 31 декабря).
    \item По введённой дате определите дату, которая была 1 квартал назад. Выведите её и проверьте, является ли полученная дата первым днём квартала (1 января, 1 апреля, 1 июля, 1 октября).
    \item По введённой дате определите дату, которая наступит через 1 год и 1 месяц. Выведите её и проверьте, является ли день полученной даты первым числом месяца.
    \item По введённой дате определите дату, которая была 1 год и 1 месяц назад. Выведите её и проверьте, является ли день полученной даты последним числом месяца.
    \item По введённой дате определите дату, которая наступит через 366 дней (чтобы перепрыгнуть через год). Выведите её и проверьте, является ли полученная дата високосным днём (29 февраля).
\end{enumerate}

\subsection{Оператор \texttt{do...while}}

\subsubsection*{Задачи}

Решите следующие задачи, используя цикл \texttt{do...while}. Все задачи предполагают последовательный ввод чисел, оканчивающийся нулём. Нулевое значение является признаком окончания ввода и в вычислениях \textbf{не участвует}. Обеспечьте корректную обработку граничных случаев: пустая последовательность (только 0), отсутствие подходящих чисел, деление на ноль, извлечение корня из отрицательного числа и т.п. При необходимости выводите сообщения об ошибках.

\textbf{Указание}. Для целочисленных операций:
\begin{enumerate}
\item Остаток при делении $a$ на $b$: \verb|a \% b|.
    \item Целая часть частного: \verb|a / b| (при целочисленном делении).
    \item Последняя цифра числа $n$: \verb|n \% 10|.
    \item Предпоследняя цифра: \verb|(n / 10) \% 10|.
\end{enumerate}

\begin{enumerate}
    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите максимальное число и количество чисел, больших 5 (кроме завершающего нуля).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите минимальное число и количество чисел, у которых последняя цифра равна 0 (кроме завершающего нуля).

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите сумму синусов всех чисел и третье число последовательности (если чисел меньше трёх — вывести сообщение об ошибке).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите сумму всех нечётных чисел и количество чисел, делящихся на 3 (кроме завершающего нуля).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите количество двузначных натуральных чисел и минимальную последнюю цифру среди всех введённых чисел (кроме завершающего нуля).

    \item Последовательно вводятся натуральные числа, оканчивающиеся нулём. Выведите количество трёхзначных палиндромов (чисел, которые читаются одинаково слева направо и справа налево, например, 121, 343) (кроме завершающего нуля).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите сумму всех чисел и предпоследнее число последовательности (если чисел меньше двух — вывести сообщение об ошибке).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите произведение всех чисел (кроме завершающего нуля) и второе число последовательности (если чисел меньше двух — вывести сообщение об ошибке).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите среднее арифметическое всех чисел и максимум модуля введённых чисел (кроме завершающего нуля).

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее геометрическое всех чисел (кроме завершающего нуля) и минимум модуля введённых чисел. \\
    \textbf{Примечание}: среднее геометрическое определено только для положительных чисел. Если есть неположительные — вывести сообщение об ошибке. \\
    Формула: $\left(a_1 a_2 \dots a_n\right)^{1/n}$.

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее квадратическое всех чисел (кроме завершающего нуля) и минимум квадрата введённых чисел. \\
    Формула: $\sqrt{\frac{a_1^2 + a_2^2 + \dots + a_n^2}{n}}$.

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее гармоническое всех чисел (кроме завершающего нуля) и максимум квадрата введённых чисел. \\
    \textbf{Примечание}: среднее гармоническое не определено, если есть нули или числа разных знаков. Проверяйте знаменатель. \\
    Формула: $\frac{n}{\frac{1}{a_1} + \frac{1}{a_2} + \dots + \frac{1}{a_n}}$.

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее арифметическое модулей всех чисел и максимум синусов введённых чисел (кроме завершающего нуля).

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее гармоническое модулей всех чисел (кроме завершающего нуля) и минимум синусов введённых чисел. \\
    \textbf{Примечание}: модули положительны — среднее гармоническое определено, если только не все числа нулевые.

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее квадратическое модулей всех чисел (кроме завершающего нуля) и минимум косинусов введённых чисел.

    \item Последовательно вводятся вещественные числа, оканчивающиеся нулём. Выведите среднее геометрическое модулей всех чисел (кроме завершающего нуля) и максимум косинусов введённых чисел. \\
    \textbf{Примечание}: модули неотрицательны — если есть ноль, среднее геометрическое = 0.

    \item Последовательно вводятся натуральные числа, оканчивающиеся нулём. Выведите среднее арифметическое квадратов всех чисел (кроме завершающего нуля) и максимальную последнюю цифру среди всех чисел.

    \item Последовательно вводятся натуральные числа, оканчивающиеся нулём. Выведите среднее геометрическое квадратов всех чисел (кроме завершающего нуля) и минимальную последнюю цифру среди всех чисел.

    \item Последовательно вводятся натуральные числа, оканчивающиеся нулём. Выведите среднее квадратическое квадратов всех чисел (кроме завершающего нуля) и максимальную предпоследнюю цифру среди всех чисел.

    \item Последовательно вводятся натуральные числа, оканчивающиеся нулём. Выведите среднее гармоническое квадратов всех чисел (кроме завершающего нуля) и минимальную предпоследнюю цифру среди всех чисел.

    \item Последовательно вводятся натуральные числа от 1 до 999, оканчивающиеся нулём. Выведите максимальную сумму цифр в числах и среднее арифметическое сумм цифр (кроме завершающего нуля).

    \item Последовательно вводятся натуральные числа от 1 до 999, оканчивающиеся нулём. Выведите минимальную сумму цифр в числах и среднее гармоническое сумм цифр (кроме завершающего нуля).

    \item Последовательно вводятся натуральные числа от 1 до 999, оканчивающиеся нулём. Выведите минимальную сумму количества сотен и единиц в числах и среднее геометрическое сумм цифр (кроме завершающего нуля). \\
    \textbf{Пример}: для числа 347: сотни = 3, единицы = 7, сумма = 10.

    \item Последовательно вводятся натуральные числа от 1 до 999, оканчивающиеся нулём. Выведите максимальную сумму количества сотен и единиц в числах и среднее квадратическое сумм цифр (кроме завершающего нуля).

    \item Последовательно вводятся целые числа, оканчивающиеся нулём. Выведите среднее геометрическое всех чётных чисел (кроме завершающего нуля) и максимум среди нечётных чисел. \\
    \textbf{Примечание}: если чётных чисел нет — вывести сообщение об ошибке. Учтите, что среднее геометрическое требует положительных значений.
\end{enumerate}

\subsection{Цикл \texttt{for}}

\subsubsection*{Задачи}

Решите следующие задачи, используя цикл \texttt{for}. Все задачи должны использовать именно \texttt{for} (не \texttt{while} или \texttt{do...while}). Обеспечьте корректную обработку граничных случаев: деление на ноль, отрицательные числа, пустые диапазоны и т.п.

\begin{enumerate}
    \item Найдите количество трёхзначных чисел в диапазоне $[100; 999]$, в которых вторая цифра равна сумме первой и третьей цифры.

    \item Найдите количество трёхзначных чисел в диапазоне $[100; 999]$, в которых сумма первых двух цифр равна третьей цифре.

    \item Найдите количество трёхзначных чисел в диапазоне $[100; 999]$, в которых сумма последних двух цифр равна первой цифре.

    \item Найдите все натуральные числа в диапазоне $[m; n]$ ($1 \leqslant m \leqslant n \leqslant 999$), которые равны сумме квадратов своих цифр. \\
    \textbf{Пример}: $1^2 + 3^2 + 0^2 = 10$ — не подходит; $1^2 + 6^2 + 3^2 = 46$ — не подходит.

    \item Найдите все натуральные числа в диапазоне $[m; n]$ ($1 \leqslant m \leqslant n \leqslant 999$), которые равны сумме кубов своих цифр. \\
    \textbf{Пример}: $153 = 1^3 + 5^3 + 3^3$ — подходит.

    \item Найдите все натуральные числа в диапазоне $[m; n]$ ($1 \leqslant m \leqslant n \leqslant 999$), которые равны сумме своих цифр. \\
    \textbf{Пример}: $18 = 1 + 8 = 9$ — не подходит; $1 = 1$ — подходит.

    \item Найдите все натуральные делители числа $n \in \mathbb{N}$ ($n > 0$). Выведите их в порядке возрастания.

    \item Определите, является ли число $n \in \mathbb{N}$ ($n > 1$) простым. Выведите «Да» или «Нет».

    \item Найдите все натуральные числа в диапазоне $[m; n]$ ($1 \leqslant m \leqslant n \leqslant 999$), которые делятся на свою последнюю цифру. \\
    \textbf{Примечание}: если последняя цифра — 0, число не учитывается (деление на ноль).

    \item Напечатайте таблицу перевода двоичных чисел от $1_2$ до $11111_2$ (т.е. от 1 до 31 в десятичной) в десятичную систему счисления.

    \item Напечатайте таблицу перевода восьмеричных чисел от $1_8$ до $777_8$ (т.е. от 1 до 511 в десятичной) в десятичную систему счисления.

    \item Напечатайте таблицу умножения (от 1×1 до 10×10).

    \item Напечатайте первые 20 чисел Фибоначчи ($f_1 = 1$, $f_2 = 1$, $f_{n} = f_{n-1} + f_{n-2}$ для $n > 2$).

    \item Найдите все трёхзначные числа в диапазоне $[100; 999]$, которые при зачёркивании средней цифры уменьшаются в 7 раз. \\
    \textbf{Пример}: число 357 → зачёркиваем 5 → получаем 37; $357 / 37 = 9.648$ — не подходит.

    \item Найдите сумму всех натуральных делителей числа $n \in \mathbb{N}$ ($n > 0$).

    \item Вычислите $a^n$, где $a \in \mathbb{R}$, $n \in \mathbb{Z}$, $n \geqslant 0$. \\
    \textbf{Примечание}: если $n < 0$, вывести сообщение об ошибке. Используйте только умножение (не \verb|Math.pow|).

    \item Найдите сумму всех нечётных натуральных чисел в диапазоне $[m; n]$ ($1 \leqslant m \leqslant n \leqslant 1000$).

    \item Найдите сумму всех чётных натуральных чисел в диапазоне $[m; n]$ ($1 \leqslant m \leqslant n \leqslant 1000$).

    \item Найдите все общие делители натуральных чисел $n$ и $m$ ($n > 0$, $m > 0$). Выведите их в порядке возрастания.

    \item Найдите все натуральные числа в диапазоне $[m; n]$ ($10 \leqslant m \leqslant n \leqslant 999$), которые делятся на свою предпоследнюю цифру. \\
    \textbf{Примечание}: если предпоследняя цифра — 0, число не учитывается.

    \item Напечатайте все трёхзначные палиндромы (числа, которые читаются одинаково слева направо и справа налево, например, 121, 343) в диапазоне $[100; 999]$.

    \item Найдите все трёхзначные числа в диапазоне $[100; 999]$, которые пропорциональны числу, составленному из второй и третьей цифр. \\
    \textbf{Пример}: число 135 → вторая и третья цифры = 35; $135 / 35 = 3.857$ — не целое → не подходит. \\
    \textbf{Уточнение}: пропорциональны = делятся без остатка.

    \item Найдите все четырёхзначные числа в диапазоне $[1000; 9999]$, в которых сумма первых двух цифр равна сумме последних двух цифр.

    \item Найдите все четырёхзначные числа в диапазоне $[1000; 9999]$, в которых сумма крайних цифр равна сумме средних цифр.

    \item Найдите все четырёхзначные числа в диапазоне $[1000; 9999]$, в которых сумма первой и третьей цифр равна сумме второй и четвёртой цифр.
\end{enumerate}

\subsection{Цикл \texttt{while}}

\subsubsection*{Задачи}

Решите следующие задачи, используя цикл \texttt{while}. Использование \texttt{for} или \texttt{do...while} не допускается. Все задачи предполагают, что количество итераций заранее неизвестно и определяется в процессе выполнения. Обеспечьте обработку граничных случаев: нули, единицы, отрицательные числа, переполнения.

\begin{enumerate}
    \item Дано натуральное число $n$. Найдите сумму его цифр, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите количество его цифр, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите произведение его цифр, используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, является ли оно палиндромом (читается одинаково слева направо и справа налево), используя \texttt{while}. \\
    \textbf{Указание}: постройте зеркальное число и сравните.

    \item Дано натуральное число $n$. Удалите из него все чётные цифры и выведите результат (если получилось пустое число — вывести 0). Используйте \texttt{while}.

    \item Дано натуральное число $n$. Проверьте, является ли оно факториалом какого-либо натурального числа. Если да — выведите это число, иначе — сообщение «Не является факториалом». \\
    \textbf{Пример}: $120 = 5!$ → вывести 5.

    \item Дано натуральное число $n$. Найдите наименьшее $k$, такое что $k! \geqslant n$. Используйте \texttt{while}.

    \item Дано натуральное число $n$. Разложите его на простые множители и выведите их в порядке возрастания (с повторениями). Используйте \texttt{while}.

    \item Даны два натуральных числа $a$ и $b$. Найдите их наибольший общий делитель (НОД) с помощью алгоритма Евклида, используя \texttt{while}.

    \item Даны два натуральных числа $a$ и $b$. Найдите их наименьшее общее кратное (НОК), используя \texttt{while} и НОД.

    \item Дано натуральное число $n$. Переведите его в двоичную систему счисления, используя \texttt{while}. Выведите результат как число (не строку).

    \item Дано натуральное число $n$. Переведите его в восьмеричную систему счисления, используя \texttt{while}. Выведите результат как число.

    \item Дано натуральное число $n$. Определите, сколько раз в нём встречается цифра 7, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите максимальную цифру в числе, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите минимальную цифру в числе, используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, содержит ли оно хотя бы одну цифру, равную 0, используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, все ли его цифры нечётные, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите число, составленное из его цифр в обратном порядке (зеркальное отражение), используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, является ли оно степенью двойки (т.е. $n = 2^k$ для некоторого $k \geqslant 0$), используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, является ли оно степенью тройки, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите сумму всех его делителей, используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, является ли оно совершенным (т.е. сумма его собственных делителей равна самому числу), используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите количество нулей в его двоичном представлении, используя \texttt{while}.

    \item Дано натуральное число $n$. Найдите количество единиц в его двоичном представлении, используя \texttt{while}.

    \item Дано натуральное число $n$. Определите, можно ли его представить в виде суммы двух квадратов натуральных чисел, используя \texttt{while}. \\
    \textbf{Пример}: $25 = 3^2 + 4^2$ → можно.
\end{enumerate}

\section{Семинар 2}

\subsection{Задание 1: Манипуляции со строками с помощью StringBuilder}
  \textbf{Описание:} Напишите программу, которая читает с клавиатуры целое число $n$ ($1 \leq n \leq 1000$), затем $n$ строк (каждая длиной до 100 символов). Используя только StringBuilder для сборки результата, обработайте каждую строку согласно условию варианта (например, инвертируйте, удалите символы и т.д.), затем добавьте её в результат, если она удовлетворяет фильтру варианта (например, длина, наличие символов). Между добавленными строками вставьте фиксированный разделитель "---". В конце добавьте общее количество символов в результате. Выводите на экран. Запрещено использовать String methods вроде reverse, replaceAll, format, join; все операции вручную через циклы и append/insert/delete.

  \begin{enumerate}
    \item Обработка: инвертировать строку; Фильтр: длина > 5
    \item Обработка: удалить все гласные; Фильтр: начинается с согласной
    \item Обработка: удвоить каждый символ; Фильтр: содержит цифру
    \item Обработка: перевести в верхний регистр; Фильтр: заканчивается на 'a'
    \item Обработка: удалить пробелы; Фильтр: длина четная
    \item Обработка: добавить '!' в конец; Фильтр: не содержит 'e'
    \item Обработка: заменить 'a' на '@'; Фильтр: больше 3 гласных
    \item Обработка: удалить дубликаты символов; Фильтр: все символы уникальны
    \item Обработка: отсортировать символы по алфавиту (вручную); Фильтр: длина < 10
    \item Обработка: добавить индекс в начало; Фильтр: содержит специальный символ
    \item Обработка: обернуть в скобки; Фильтр: начинается с цифры
    \item Обработка: удалить последние 2 символа; Фильтр: длина >= 3
    \item Обработка: повторить строку twice; Фильтр: не пустая
    \item Обработка: заменить пробелы на '\_'; Фильтр: содержит пробел
    \item Обработка: удалить все цифры; Фильтр: была хотя бы одна цифра
    \item Обработка: инвертировать регистр; Фильтр: смешанный регистр
    \item Обработка: добавить длину в конец; Фильтр: длина делится на 3
    \item Обработка: удалить гласные в начале; Фильтр: заканчивается гласной
    \item Обработка: удвоить гласные; Фильтр: только гласные
    \item Обработка: заменить согласные на '*'; Фильтр: больше согласных
    \item Обработка: добавить 'prefix-'; Фильтр: не начинается с 'p'
    \item Обработка: удалить середину (если длина >2); Фильтр: длина нечетная
    \item Обработка: циклический сдвиг влево; Фильтр: длина >1
    \item Обработка: циклический сдвиг вправо; Фильтр: содержит 'z'
    \item Обработка: удалить все кроме букв; Фильтр: была не-буква
  \end{enumerate}


\subsection{Задание 2: Операции с HashMap без упрощений}
  \textbf{Описание:} Напишите программу, которая читает целое число $m$ ($1 \leq m \leq 500$), затем $m$ пар: строка-ключ (до 50 символов) и целое значение (-1000..1000). Используя HashMap<String, Integer>, сохраните (при дубликатах ключей суммируйте значения). Затем прочитайте $k$ ($1 \leq k \leq 100$) запросов, каждый — строка. Для каждого запроса выполните операцию варианта над значениями, чьи ключи соответствуют условию варианта (например, начинаются с запроса, содержат и т.д.), и выведите результат. Если ничего не найдено, выведите 0. Запрещено использовать streams, Collectors, computeIf; все через циклы по keySet или entrySet, contains, get, put.

  \begin{enumerate}
    \item Операция: сумма значений; Условие: ключ начинается с запроса
    \item Операция: максимум значения; Условие: ключ заканчивается запросом
    \item Операция: количество ключей; Условие: ключ содержит запрос
    \item Операция: минимум значения; Условие: ключ равен запросу (equals)
    \item Операция: среднее значение (int); Условие: длина ключа = длине запроса
    \item Операция: произведение значений; Условие: ключ лексикографически > запрос
    \item Операция: сумма квадратов; Условие: ключ имеет подстроку запрос реверс
    \item Операция: количество положительных; Условие: ключ в нижнем регистре содержит запрос
    \item Операция: максимум по модулю; Условие: ключ без гласных содержит запрос
    \item Операция: сумма только четных; Условие: ключ с цифрами содержит запрос
    \item Операция: количество уникальных значений; Условие: ключ короче запроса
    \item Операция: минимум среди отрицательных; Условие: ключ длиннее запроса
    \item Операция: сумма абсолютных; Условие: ключ стартует с реверса запроса
    \item Операция: произведение нечетных; Условие: ключ в верхнем регистре = запрос
    \item Операция: количество нулей; Условие: ключ содержит запрос дважды
    \item Операция: максимум среди четных; Условие: ключ без пробелов = запрос
    \item Операция: сумма делимых на 3; Условие: ключ с удаленными цифрами содержит запрос
    \item Операция: минимум по квадрату; Условие: ключ инвертированный содержит запрос
    \item Операция: количество > среднего; Условие: ключ с удвоенными символами содержит запрос
    \item Операция: произведение положительных; Условие: ключ без последних 2 символов = запрос
    \item Операция: сумма первых цифр значений; Условие: ключ с префиксом "a" содержит запрос
    \item Операция: максимум разницы с min; Условие: ключ циклически сдвинутый содержит запрос
    \item Операция: количество пар значений; Условие: ключ с заменой 'a' на 'b' содержит запрос
    \item Операция: сумма факториалов (малых); Условие: ключ только буквы содержит запрос
    \item Операция: минимум среди делимых на 5; Условие: ключ с добавленным суффиксом содержит запрос
  \end{enumerate}


\subsection{Задание 3: Множества с HashSet и ручными операциями}
  \textbf{Описание:} Напишите программу, которая читает $p$ ($1 \leq p \leq 800$), затем $p$ целых чисел (1..10000). Используя HashSet<Integer>, сохраните уникальные. Затем прочитайте $q$ ($1 \leq q \leq 200$) запросов, каждый — целое число. Для каждого выполните действие варианта: например, если есть, удалите и добавьте трансформацию (квадрат, удвоение и т.д.), если трансформация уже есть, пропустите. В конце выведите элементы в порядке возрастания (сортируйте вручную в массив, без TreeSet или sorted). Запрещено использовать containsAll, addAll; все через add, remove, contains, iterator.

  \begin{enumerate}
    \item Действие: удалить и добавить квадрат
    \item Действие: удалить и добавить удвоенное
    \item Действие: удалить и добавить +1
    \item Действие: удалить и добавить факториал (малый)
    \item Действие: удалить и добавить корень (int)
    \item Действие: удалить и добавить обратное (1/x если !=0)
    \item Действие: удалить и добавить модуль
    \item Действие: удалить и добавить сумму цифр
    \item Действие: удалить и добавить произведение цифр
    \item Действие: удалить и добавить реверс цифр
    \item Действие: удалить и добавить +100
    \item Действие: удалить и добавить -50
    \item Действие: удалить и добавить куб
    \item Действие: удалить и добавить лог2 (int)
    \item Действие: удалить и добавить fib next (простой fib)
    \item Действие: удалить и добавить prime next
    \item Действие: удалить и добавить делимое на 3
    \item Действие: удалить и добавить битовый сдвиг
    \item Действие: удалить и добавить XOR 42
    \item Действие: удалить и добавить AND 255
    \item Действие: удалить и добавить кол-во бит 1
    \item Действие: удалить и добавить pow 2
    \item Действие: удалить и добавить div 2
    \item Действие: удалить и добавить mul 3
    \item Действие: удалить и добавить mod 100
  \end{enumerate}

\subsection{Задание 4: Списки с ArrayList и ручными манипуляциями}
  \textbf{Описание:} Напишите программу, которая читает $r$ ($1 \leq r \leq 600$), затем $r$ целых (-5000..5000). Используя ArrayList<Integer>, сохраните. Затем прочитайте $s$ ($1 \leq s \leq 150$) операций, каждая в формате строки (парсите вручную без split упрощений). Операция варианта: например, "add X Y" - добавить X в Y, но с условием; "remove Z" - удалить Z если условие; "swap A B" - swap если разница >k. После операций выведите список по условию варианта (реверс, только четные и т.д.) через цикл, без Collections.reverse/sort. Запрещено использовать subList, sort, reverse; все get/set/add/remove вручную.

  \begin{enumerate}
    \item Операция: add если X >0, в позицию Y mod size
    \item Операция: remove если Z четный
    \item Операция: swap если A+B even
    \item Операция: add X в начало если X odd
    \item Операция: remove последний если >0
    \item Операция: swap первый и последний если size>1
    \item Операция: add X в конец если not contains
    \item Операция: remove по значению если exists
    \item Операция: swap если |A-B|>10
    \item Операция: add если X prime
    \item Операция: remove если divisible 5
    \item Операция: swap random (но fixed seed)
    \item Операция: add в середину
    \item Операция: remove дубликаты (ручной)
    \item Операция: swap соседние
    \item Операция: add сумму соседей
    \item Операция: remove min
    \item Операция: swap max и min
    \item Операция: add среднее
    \item Операция: remove > average
    \item Операция: swap если both positive
    \item Операция: add квадрат last
    \item Операция: remove first negative
    \item Операция: swap every other
    \item Операция: add 0 в позиции multiples 3
  \end{enumerate}


\section{Семинар 3 (простейшее ООП)}

Напишите программу в соответствии с заданием, 
используя объектно-ориентированный стиль программирования. 
В программе должны быть отражены свойства объектно-ориентированного 
программирования: 
инкапсуляция, наследование и полиморфизм (наряду с этим в некоторых
вариантах нужно реализовывать абстрактные классы и методы). 

Обращаем внимание, что каждый класс следует поместить в отдельный файл.

\begin{enumerate}
\item Программа работы со списком работников. Каждый работник определяется фамилией, именем и отчеством, должностью 
(преподаватель и лаборант). Для преподавателя указывается количество часов в год, а для лаборанта -- количество ставок.
Дополнительно в программу вводится стоимость одного часа и стоимость ставки (за год). После ввода необходимо вывести на экран
список работников в порядке возрастания оплаты за год, при этом в списке должны быть указаны ФИО, должность, количество часов/
количество ставок и <<стоимость>> работника.
\item Программа работы со списком учебных заведений (школ и ВУЗов). Школа определяется номером, количеством
учащихся и специализацией (физ-мат, гуманитарный); ВУЗ -- названием, количеством студентов, наличием магистратуры, наличием
аспирантуры. Программа должна предоставлять возможность ввести информацию о ВУЗах и школах, после чего
вывести информацию о школах/ВУЗах в порядке убывания количества учащихся (в независимости от типа учебного заведения).
В списке должна выводиться вся информация, что была введена.
\item Программа суммирования последовательностей двух типов: $\frac{n}{1!}+\frac{n+1}{2!}+\dots+\frac{n+m}{(m+1)!}$ и
$\frac{n}{2^1}+\dots+\frac{n+m}{2^{m+1}}$. $n$ и $m$ вводятся с клавиатуры
\item Программа нахождения интеграла методом прямоугольников для функций двух видов: $ax^3+bx^2+cx+d$ и $a\sin x+ be^x$.
\item Программа решения уравнений двух видов методом дихотомии: $ax^3+bx^2+cx+d=0$ и $a\sin x+ be^x=c$.
\item Программа <<часы>>. При запуске пользователь выбирает способ вывода времени: часы:минуты или стрелки (второе -- в графическом
режиме).
\item У игрока может быть несколько принадлежностей (до 10): бластеры (с индикатором количества заряда и уровня
бластера от 1 до 5), 
витамины (с количеством оставшихся таблеток), плащи (характеризуются уровнем защиты). Написать программу, которая 
вводит с клавиатуры информацию об имеющихся игровых принадлежностях, после чего выводит информацию на экран.
Данная программа (в части вывода данных) может быть фрагментом игры.
\item Написать программу, отображающую на экране два индикатора: цифровой и в виде полоски нарастающей длины. 
При этом пользователь может выбрать: отображать два цифровых индикатора, один цифровой -- один в виде
полоски или два в виде полоски. Значения на одном индикаторе увеличиваются, на втором -- уменьшаются.
\item Написать программу, в которой пользователь выбирает тип файла, куда записывается информация 
(тестовый или типизированный), после чего вводит последовательность целых чисел, которая записывается
в указанный тип файла.
\item Напишите программу, для работы с бегущими строками: пользователь задает от 1 до 24 строк и выбирает
режим работы каждой строки: слева направо или справа налево (выбор производится для каждой строки по отдельности).
\item В текстовом режиме на экране отображаются квадратик и крестик, с помощью клавиши TAB происходит переключение
между квадратиком и крестиком, каждую фигуру пользователь имеет возможность передвигать с помощью клавиш-стрелок (независимо).
\item Пользователь задает простейший тест, состоящий из вопросов двух видов: с выбором варианта ответа и с вводом верного 
ответа; после чего компьютер тестирует (другого) пользователя по введенному тесту.
\item Создайте программу сортировки массива натуральных чисел, которая сортирует по выбору пользователя: 
1) по возрастания; 2) по убыванию; 3) по возрастанию сумм цифр в числе; 4) по убыванию сумм цифр в числе.
\item Создайте программу вывода всех элементов заданного массива по выбору пользователя: 1) в прямом порядке; 2)
в обратном порядке; 3) в случайном порядке; 4) в челночном порядке (первый-последний-второй-предпоследний и т. д.).
\item Создайте программу суммирования двух чисел, при этом по выбору пользователя либо ввод осуществляется путем выбора
числа с помощью клавиш-стрелок, либо число вводится с клавиатуры.
\item Напишите программу-игру <<чет-нечет>>. Один игрок загадывает <<чет>> или <<нечет>>, а второй угадывает. За один раунд 
идет 10 угадываний. Пользователь выбирает в начала работы программы ее режим работы: пользователь-компьютер,
компьютер-пользователь, компьютер-компьютер или пользователь-пользователь.
\item С клавиатуры задается информация о рисунке, состоящего из нескольких окружностей и прямоугольников со сторонами,
параллельными осям, после этого программа выводит на экран рисунок, сумму площадей и сумму периметров выведенных фигур.
\item Пользователь имеет несколько счетов трех видов: первый вид характеризуется тем, что за его использование с него списывается 1
рубль в месяц, второй -- тем, что количество денег на нем увеличивается на 1\% в месяц,
третий -- тем, что с вероятностью 50\% количество денег на нем за месяц не меняется, с вероятностью 50\% --
увеличивается на 2\%. Пользователь задает список своих счетов с указанием количества денег на них. После чего
программа должна вывести таблицу изменения сумм, размещенных на указанных счетах, в течении года.
\item Пользователь задает информацию о своих контактных сведениях /он может задать один или несколько
телефонов, один или несколько адресов и т. д./: телефон (код города+сам телефон), адрес (город, улица, дом,
корпус, квартира), номер ICQ, e-mail; после чего он может выводить список контактов, изменять информацию
по контактному сведению любого вида, добавлять и удалять контакт.
\item Программа нахождения производной для функций двух видов: $ax^3+bx^2+cx+d$ и $a\sin x+ be^x$ (результат -- формула).
\item Пользователь размещает на экране несколько рисунков (человечек, колобок, столбик); после чего человечек
подпрыгивает, колобок перекатывается влево-вправо, а столбик стоит на месте.
 \item Программа библиотеки, в которой хранятся книги (описываются автором, названием, количеством страниц) и
CD-диски (название CD, производитель, количество треков). Программа должна позволять добавлять в библиотеку книги и 
CD-диски, а также выводить на экран содержимое библиотеки.
\item Конфигуратор компьютеров. Пользователь выбирает конфигурацию компьютера: процессор (марка, быстродействие), 
один или несколько жестких дисков (марка, емкость), клавиатуру, мышь, принтеры (не обязательно, марка, тип). После
чего ему выводится на экран полная информацию о компьютере (включая стоимость).
\item Формирование заказа в магазине: пользователь выбирает тип товара: рубашка (указывается ее размер), 
ткань (указывается длина и ширина), нитки (выбирается цвет и длина). После чего ему выводится полная информация
о заказе (включая стоимость).
\item Пользователь магазина выбирает конфигурацию велосипеда, который будет собран для него: тип рамы 
(обычная, женская, изогнутая); колеса (размер - 24, 26 или 28); велокомпьютер (может отсутствовать, если есть, то
выбирается беспроводной он или нет); амортизатор (может отсутствовать, если есть, то -- одноподвес или двухподвес). 
После чего ему выводится на экран полная информация о получившемся велосипеде.
\end{enumerate}

\section{Семинар 4 (методы Object)}

Создайте класс в соответствии с вашим вариантом, реализуйте корректно в нём
методы \texttt{clone}, \texttt{equals}, \texttt{hashCode}, \texttt{toString}.

В случае некорректности данных для инициализации, вызывайте исключение. 

\begin{enumerate}
    \item Класс «Точка в 3D»: поля \texttt{x}, \texttt{y}, \texttt{z} (тип \texttt{double}).
    \item Класс «Цвет в RGB»: поля \texttt{red}, \texttt{green}, \texttt{blue} (тип \texttt{int}, значения от 0 до 255).
    \item Класс «Время суток»: поля \texttt{hour} (0–23), \texttt{minute} (0–59), \texttt{second} (0–59) (все — \texttt{int}).
    \item Класс «Геокоординаты с высотой»: поля \texttt{latitude}, \texttt{longitude} (\texttt{double}), \texttt{altitude} (\texttt{int}, в метрах).
    \item Класс «Дробь с единицей измерения»: поля \texttt{numerator}, \texttt{denominator} (\texttt{int}, знаменатель $\neq 0$), \texttt{unit} (\texttt{String}).
    \item Класс «Комплексное число с меткой»: поля \texttt{re}, \texttt{im} (\texttt{double}), \texttt{label} (\texttt{String}).
    \item Класс «Размер экрана с ориентацией»: поля \texttt{width}, \texttt{height} (\texttt{int}), \texttt{orientation} (\texttt{String}: \texttt{"portrait"} или \texttt{"landscape"}).
    \item Класс «Погодные данные»: поля \texttt{temp} (температура в °C, \texttt{double}), \texttt{humidity} (влажность в \%, \texttt{int}), \texttt{pressure} (давление в мм рт.\,ст., \texttt{int}).
    \item Класс «Скорость в 3D»: поля \texttt{vx}, \texttt{vy}, \texttt{vz} (тип \texttt{double}).
    \item Класс «Пиксель»: поля \texttt{x}, \texttt{y} (\texttt{int}), \texttt{brightness} (\texttt{int}, 0–255).
    \item Класс «Дата»: поля \texttt{day} (1–31), \texttt{month} (1–12), \texttt{year} (\texttt{int}, $\geq 1900$).
    \item Класс «Валютная пара с курсом»: поля \texttt{base}, \texttt{quote} (\texttt{String}), \texttt{rate} (\texttt{double}).
    \item Класс «Углы Эйлера»: поля \texttt{yaw}, \texttt{pitch}, \texttt{roll} (в градусах, \texttt{double}).
    \item Класс «Физическая величина»: поля \texttt{value} (\texttt{double}), \texttt{unit} (\texttt{String}), \texttt{precision} (\texttt{int}, знаков после запятой).
    \item Класс «Настройки звука»: поля \texttt{left}, \texttt{right}, \texttt{master} (\texttt{int}, 0–100).
    \item Класс «Коэффициенты плоскости»: поля \texttt{a}, \texttt{b}, \texttt{c} (\texttt{double}, уравнение $ax + by + cz = 0$).
    \item Класс «Шахматная позиция»: поля \texttt{file} (\texttt{char}, от \texttt{'a'} до \texttt{'h'}), \texttt{rank} (\texttt{int}, 1–8), \texttt{piece} (\texttt{String}, например \texttt{"king"}).
    \item Класс «Интервал с единицей измерения»: поля \texttt{start}, \texttt{end} (\texttt{double}), \texttt{unit} (\texttt{String}).
    \item Класс «Разрешение с частотой»: поля \texttt{width}, \texttt{height} (\texttt{int}), \texttt{refreshRate} (\texttt{int}, в Гц).
    \item Класс «Именованный вектор»: поля \texttt{x}, \texttt{y}, \texttt{z} (\texttt{double}), \texttt{name} (\texttt{String}).
    \item Класс «Позиция с меткой времени»: поля \texttt{x}, \texttt{y} (\texttt{double}), \texttt{timestamp} (\texttt{long}).
    \item Класс «Параметры изображения»: поля \texttt{brightness}, \texttt{contrast}, \texttt{saturation} (\texttt{int}, 0–100).
    \item Класс «Квадратный трёхчлен»: поля \texttt{a}, \texttt{b}, \texttt{c} (\texttt{double}, $a \neq 0$).
    \item Класс «GPS-точка»: поля \texttt{lat}, \texttt{lon} (\texttt{double}), \texttt{accuracy} (\texttt{float}, в метрах).
    \item Класс «Финансовая операция»: поля \texttt{amount} (\texttt{double}), \texttt{currency} (\texttt{String}, например \texttt{"RUB"}), \texttt{date} (\texttt{String} в формате \texttt{"YYYY-MM-DD"}).
\end{enumerate}

\section{Семинар 5 (списки, inner, static классы и Iterator)}

Реализуйте список (самостоятельно, без использования библиотеки) согласно
вашему варианту. В необходимых случаях используйте static и inner-классы. 

\begin{enumerate}
\item Реализуйте класс \texttt{MyLinkedList}, содержащий внутренний класс \texttt{Node} и вложенный итератор. Метод \texttt{add(int value)} добавляет элемент в конец списка. Метод \texttt{remove(int value)} удаляет первое вхождение значения. Метод \texttt{print()} выводит все элементы. Итератор последовательно возвращает все элементы.

\item Реализуйте класс \texttt{MyLinkedList} с методом \texttt{add(int value)}, добавляющим элемент в начало. Метод \texttt{remove(int index)} удаляет элемент по индексу. Метод \texttt{print()} выводит все элементы. Итератор возвращает элементы в порядке хранения.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} вставляет элемент с сохранением неубывающего порядка. Метод \texttt{remove(int value)} удаляет все вхождения значения. Метод \texttt{print()} выводит все элементы. Итератор возвращает элементы по порядку.

\item Реализуйте класс \texttt{MyLinkedList} с методом \texttt{add(int target, int value)}, добавляющим \texttt{value} после первого вхождения \texttt{target} (если \texttt{target} не найден — в конец). Метод \texttt{remove(int value)} удаляет первое вхождение. Метод \texttt{print()} выводит все элементы. Итератор возвращает все элементы.

\item Реализуйте класс \texttt{MyLinkedList} с методом \texttt{add(int index, int value)}, добавляющим элемент по индексу (с проверкой границ). Метод \texttt{remove(int index)} удаляет элемент по индексу. Метод \texttt{print()} выводит все элементы. Итератор возвращает элементы в прямом порядке.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeLast()} удаляет последний элемент. Метод \texttt{print()} выводит все элементы. Итератор возвращает все элементы.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет только уникальные значения. Метод \texttt{remove(int value)} удаляет все вхождения. Метод \texttt{print()} выводит все элементы. Итератор возвращает элементы без дубликатов (в порядке первого вхождения).

\item Реализуйте класс \texttt{MyLinkedList} с методом \texttt{addAll(int[] values)}, добавляющим все элементы массива в конец. Метод \texttt{remove(int value)} удаляет все вхождения. Метод \texttt{print(int k)} выводит первые $k$ элементов. Итератор возвращает все элементы.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} вставляет элемент перед первым значением, большим \texttt{value} (иначе — в конец). Метод \texttt{removeAbove(int threshold)} удаляет все элементы > \texttt{threshold}. Метод \texttt{print()} выводит все элементы. Итератор возвращает оставшиеся элементы.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeFirst()} удаляет первый элемент. Метод \texttt{printEven()} выводит только чётные элементы. Итератор возвращает только чётные значения.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в начало. Метод \texttt{removeBelow(int threshold)} удаляет все элементы < \texttt{threshold}. Метод \texttt{printOdd()} выводит только нечётные элементы. Итератор возвращает только нечётные значения.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeZeros()} удаляет все нули. Метод \texttt{printPositive()} выводит только положительные элементы. Итератор возвращает только положительные числа.

\item Реализуйте класс \texttt{MyLinkedList} с методом \texttt{add(int index, int value)}. Метод \texttt{removeEvenIndices()} удаляет элементы с чётными индексами. Метод \texttt{printOddIndices()} выводит элементы с нечётными индексами. Итератор возвращает элементы с нечётными индексами.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в начало. Метод \texttt{removeDivisibleBy(int n)} удаляет все элементы, делящиеся на $n$. Метод \texttt{print()} выводит оставшиеся элементы. Итератор возвращает элементы, не делящиеся на $n$.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeSmall(int minAbs)} удаляет элементы с $|x| < \texttt{minAbs}$. Метод \texttt{printLarge(int minAbs)} выводит элементы с $|x| \geq \texttt{minAbs}$. Итератор возвращает такие элементы.

\item Реализуйте класс \texttt{MyLinkedList} с ограниченной ёмкостью $N$: \texttt{add(int value)} добавляет в конец, при переполнении удаляется первый элемент. Метод \texttt{remove(int value)} удаляет первое вхождение. Метод \texttt{print()} выводит все элементы. Итератор возвращает все элементы в порядке хранения.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} вставляет с сохранением невозрастающего порядка. Метод \texttt{removeMax()} удаляет первое вхождение максимального элемента. Метод \texttt{print()} выводит все элементы. Итератор возвращает элементы по порядку.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeDuplicates()} оставляет только первые вхождения. Метод \texttt{printUnique()} выводит уникальные элементы. Итератор возвращает элементы без повторений.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в начало. Метод \texttt{removeNegative()} удаляет все отрицательные элементы. Метод \texttt{printNonNegative()} выводит оставшиеся. Итератор возвращает только неотрицательные числа.

\item Реализуйте класс \texttt{MyLinkedList} с методом \texttt{addAfterZero(int value)}, добавляющим \texttt{value} после каждого нуля. Метод \texttt{removeZeroPairs()} удаляет все пары (0, x). Метод \texttt{print()} выводит результат. Итератор возвращает элементы, не следующие непосредственно за 0.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeIndexEqualsValue()} удаляет элементы, у которых значение равно их индексу. Метод \texttt{print()} выводит все элементы. Итератор возвращает элементы, у которых значение $\neq$ индекс.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в начало. Метод \texttt{removeAverage()} удаляет все элементы, равные округлённому среднему арифметическому списка. Метод \texttt{print()} выводит все элементы. Итератор возвращает все элементы.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeLocalMinima()} удаляет локальные минимумы (элементы, меньшие обоих соседей). Метод \texttt{print()} выводит оставшиеся элементы. Итератор возвращает все элементы в исходном порядке.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} вставляет с сохранением неубывающего порядка. Метод \texttt{removeRange(int a, int b)} удаляет все элементы в диапазоне $[a, b]$. Метод \texttt{print()} выводит оставшиеся элементы. Итератор возвращает элементы вне диапазона.

\item Реализуйте класс \texttt{MyLinkedList}, в котором \texttt{add(int value)} добавляет в конец. Метод \texttt{removeEverySecond()} удаляет каждый второй элемент (индексы 1, 3, 5, …). Метод \texttt{print()} выводит оставшиеся элементы. Итератор возвращает элементы с чётными индексами (0, 2, 4, …).
\end{enumerate}

\section{Семинар 6 (sealed class, unit tests)}

Реализуйте решение задачи с возвратом результата в виде Sealed-классов, консольный интерфейс
для решения задачи и Unit-тесты (согласно всем принципам).

Если в задании какие-то случаи не учтены, дополните.

\begin{enumerate}
\item[1] \textbf{Анализ линейного уравнения}
Реализуйте класс \texttt{LinearEquationSolver} с методом
\texttt{static LinearResult solve(double a, double b)}, решающим уравнение \(ax + b = 0\).
Возвращаемый sealed-класс \texttt{LinearResult} имеет следующие подклассы:
\begin{itemize}
\item \texttt{NoSolution} — без полей; соответствует случаю \(a = 0, b \neq 0\).
\item \texttt{InfiniteSolutions} — без полей; случай \(a = 0, b = 0\).
\item \texttt{UniqueSolution} — содержит поле \texttt{double x}; случай \(a \neq 0\), решение \(x = -b/a\).
\end{itemize}

\item[2] \textbf{Система двух линейных уравнений}
Класс \texttt{LinearSystemSolver}, метод
\texttt{static SystemResult solve(double a1, double b1, double c1, double a2, double b2, double c2)} для системы
\[
\begin{cases}
a_1x + b_1y = c_1 \\
a_2x + b_2y = c_2
\end{cases}
\]
Sealed-класс \texttt{SystemResult}:
\begin{itemize}
\item \texttt{NoSolution} — определитель \(\Delta = a_1b_2 - a_2b_1 = 0\), но система несовместна.
\item \texttt{InfiniteSolutions} — все коэффициенты пропорциональны: \(a_1/a_2 = b_1/b_2 = c_1/c_2\).
\item \texttt{UniqueSolution} — содержит \texttt{double x, y}; \(\Delta \neq 0\), решение по формулам Крамера.
\end{itemize}

\item[3] \textbf{Пересечение прямых \(y = k_1x + b_1\) и \(y = k_2x + b_2\)}
Класс \texttt{LineIntersectionAnalyzer}, метод
\texttt{static IntersectionResult intersect(double k1, double b1, double k2, double b2)}.
Sealed-класс \texttt{IntersectionResult}:
\begin{itemize}
\item \texttt{ParallelDistinct} — \(k_1 = k_2, b_1 \neq b_2\).
\item \texttt{Coincident} — \(k_1 = k_2, b_1 = b_2\).
\item \texttt{IntersectAtPoint} — содержит \texttt{double x, y}; \(k_1 \neq k_2\), точка пересечения.
\end{itemize}

\item[4] \textbf{Площадь треугольника по трём сторонам}
Класс \texttt{HeronTriangle}, метод
\texttt{static AreaResult computeArea(double a, double b, double c)}.
Sealed-класс \texttt{AreaResult}:
\begin{itemize}
\item \texttt{InvalidTriangle} — содержит \texttt{String reason}; стороны \(\leq 0\) или \(a+b \leq c\), \(a+c \leq b\), \(b+c \leq a\).
\item \texttt{Degenerate} — содержит \texttt{double area = 0.0}; когда \(a + b = c\), \(a + c = b\) или \(b + c = a\).
\item \texttt{ValidTriangle} — содержит \texttt{double area}; вычисляется по формуле Герона.
\end{itemize}

\item[5] \textbf{Классификация треугольника}
Класс \texttt{TriangleClassifier}, метод
\texttt{static Classification classify(double a, double b, double c)}.
Sealed-класс \texttt{Classification}:
\begin{itemize}
\item \texttt{NotTriangle} — нарушено неравенство треугольника.
\item \texttt{Equilateral} — содержит \texttt{double side}; \(a = b = c\).
\item \texttt{IsoscelesRight} — содержит \texttt{double leg, double hypotenuse}; две равные стороны и выполняется \(2\cdot leg^2 = hypotenuse^2\).
\item \texttt{Isosceles} — содержит \texttt{double equalSide, double base}; две равные стороны, но не прямоугольный.
\item \texttt{ScaleneRight} — содержит \texttt{double a, double b, double c}; все стороны разные и выполняется теорема Пифагора.
\item \texttt{ScaleneAcuteOrObtuse} — содержит \texttt{double a, double b, double c}; все стороны разные, и ни один угол не прямой.
\end{itemize}

\item[6] \textbf{Проверка простоты числа}
Класс \texttt{PrimeChecker}, метод
\texttt{static Primality check(int n)}.
Sealed-класс \texttt{Primality}:
\begin{itemize}
\item \texttt{NotNatural} — содержит \texttt{int value}; \(n \leq 1\).
\item \texttt{Prime} — содержит \texttt{int value}; \(n \geq 2\) и простое.
\item \texttt{Composite} — содержит \texttt{int value, int smallestDivisor}; \(n \geq 4\) и составное.
\end{itemize}

\item[7] \textbf{Разложение на простые множители}
Класс \texttt{PrimeFactorizer}, метод
\texttt{static Factorization factorize(int n)}.
Sealed-класс \texttt{Factorization}:
\begin{itemize}
\item \texttt{InvalidInput} — содержит \texttt{int n}; \(n < 2\).
\item \texttt{PrimeNumber} — содержит \texttt{int prime}; \(n\) простое.
\item \texttt{FactorizationResult} — содержит \texttt{List<Integer> factors}; список простых множителей.
\end{itemize}

\item[8] \textbf{НОД и НОК двух целых чисел}
Класс \texttt{GcdLcmCalculator}, метод
\texttt{static GcdLcmResult compute(long a, long b)}.
Sealed-класс \texttt{GcdLcmResult}:
\begin{itemize}
\item \texttt{BothZero} — без полей; \(a = b = 0\).
\item \texttt{AtLeastOneZero} — содержит \texttt{long gcd, long lcm}; один ноль, НОД = \(|a + b|\), НОК = 0.
\item \texttt{BothNonZero} — содержит \texttt{long gcd, long lcm}; НОД и НОК вычисляются для \(|a|, |b|\).
\end{itemize}

\item[9] \textbf{Уравнение \(\sin x = a\) на отрезке \([0, 2\pi]\)}
Класс \texttt{SineEquationSolver}, метод
\texttt{static SineResult solve(double a)}.
Sealed-класс \texttt{SineResult}:
\begin{itemize}
\item \texttt{InvalidA} — содержит \texttt{double a}; \(|a| > 1\).
\item \texttt{OneSolution} — содержит \texttt{double x}; \(a = 1 \Rightarrow x = \pi/2\), \(a = -1 \Rightarrow x = 3\pi/2\).
\item \texttt{TwoSolutions} — содержит \texttt{double x1, x2}; \(|a| < 1\), \(x_1 = \arcsin(a)\), \(x_2 = \pi - \arcsin(a)\).
\end{itemize}

\item[10] \textbf{Расстояние между двумя точками}
Класс \texttt{PointDistance}, метод
\texttt{static DistanceResult compute(Point p1, Point p2)}.
Sealed-класс \texttt{DistanceResult}:
\begin{itemize}
\item \texttt{IdenticalPoints} — содержит \texttt{Point p}; \(p_1 = p_2\).
\item \texttt{PositiveDistance} — содержит \texttt{Point p1, Point p2, double distance}; расстояние > 0.
\end{itemize}

\item[11] \textbf{Взаимное расположение двух окружностей}
Класс \texttt{CircleRelationAnalyzer}, метод
\texttt{static CircleRelation analyze(double x1, double y1, double r1, double x2, double y2, double r2)}.
Sealed-класс \texttt{CircleRelation}:
\begin{itemize}
\item \texttt{InvalidInput} — содержит \texttt{double r1, r2}; \(r_1 \leq 0\) или \(r_2 \leq 0\).
\item \texttt{Disjoint} — \(d > r_1 + r_2\).
\item \texttt{TangentExternally} — содержит \texttt{Point touchPoint}; \(d = r_1 + r_2\).
\item \texttt{TangentInternally} — содержит \texttt{Point touchPoint}; \(d = |r_1 - r_2| > 0\).
\item \texttt{Intersecting} — содержит \texttt{Point p1, p2}; \(|r_1 - r_2| < d < r_1 + r_2\).
\item \texttt{OneInsideOther} — \(d < |r_1 - r_2|\).
\item \texttt{Coincident} — \(d = 0\) и \(r_1 = r_2\).
\end{itemize}

\item[12] \textbf{Факториал с проверкой переполнения}
Класс \texttt{SafeFactorial}, метод
\texttt{static FactorialResult compute(int n)}.
Sealed-класс \texttt{FactorialResult}:
\begin{itemize}
\item \texttt{NegativeInput} — содержит \texttt{int n}; \(n < 0\).
\item \texttt{Overflow} — содержит \texttt{int n}; \(n \geq 21\).
\item \texttt{Value} — содержит \texttt{long result}; \(0 \leq n \leq 20\).
\end{itemize}

\item[13] \textbf{Анализ неравенства \(ax^2 + bx + c > 0\)}
Класс \texttt{QuadraticInequalityAnalyzer}, метод
\texttt{static InequalityResult analyze(double a, double b, double c)}.
Sealed-класс \texttt{InequalityResult}:
\begin{itemize}
\item \texttt{NotQuadratic} — содержит \texttt{String message}; \(a = 0\).
\item \texttt{AlwaysTrue} — \(a > 0\) и \(D < 0\).
\item \texttt{AlwaysFalse} — \(a < 0\) и \(D < 0\).
\item \texttt{TrueOutsideInterval} — содержит \texttt{double leftRoot, rightRoot}; \(a > 0, D \geq 0\).
\item \texttt{TrueInsideInterval} — содержит \texttt{double leftRoot, rightRoot}; \(a < 0, D \geq 0\).
\end{itemize}

\item[14] \textbf{Положение точки относительно окружности}
Класс \texttt{PointCirclePosition}, метод
\texttt{static PositionResult check(double x0, double y0, double r, double x, double y)}.
Sealed-класс \texttt{PositionResult}:
\begin{itemize}
\item \texttt{InvalidCircle} — содержит \texttt{double r}; \(r \leq 0\).
\item \texttt{Inside} — содержит \texttt{Point p, double distance}; расстояние < r.
\item \texttt{OnBoundary} — содержит \texttt{Point p}; расстояние = r.
\item \texttt{Outside} — содержит \texttt{Point p, double distance}; расстояние > r.
\end{itemize}

\item[15] \textbf{Уравнение \(|x - a| = b\)}
Класс \texttt{AbsoluteEquation}, метод
\texttt{static AbsResult solve(double a, double b)}.
Sealed-класс \texttt{AbsResult}:
\begin{itemize}
\item \texttt{InvalidB} — содержит \texttt{double b}; \(b < 0\).
\item \texttt{OneSolution} — содержит \texttt{double x}; \(b = 0\).
\item \texttt{TwoSolutions} — содержит \texttt{double x1, x2}; \(b > 0\).
\end{itemize}

\item[16] \textbf{Уравнение \(|x - a| + |x - b| = c\)}
Класс \texttt{SumOfAbsEquation}, метод
\texttt{static SumAbsResult solve(double a, double b, double c)}.
Sealed-класс \texttt{SumAbsResult}:
\begin{itemize}
\item \texttt{InvalidC} — содержит \texttt{double c}; \(c < 0\).
\item \texttt{NoSolution} — содержит \texttt{double a, b, c}; \(c < |a - b|\).
\item \texttt{InfiniteSolutions} — содержит \texttt{double left, right}; \(c = |a - b|\).
\item \texttt{TwoSolutions} — содержит \texttt{double x1, x2}; \(c > |a - b|\), \(x_1 = \frac{a+b-c}{2}\), \(x_2 = \frac{a+b+c}{2}\).
\end{itemize}

\item[17] \textbf{День недели по дате}
Класс \texttt{WeekdayFinder}, метод
\texttt{static WeekdayResult find(int year, int month, int day)}.
Sealed-класс \texttt{WeekdayResult}:
\begin{itemize}
\item \texttt{InvalidDate} — содержит \texttt{int year, month, day}; некорректная дата.
\item \texttt{Valid} — содержит \texttt{java.time.DayOfWeek weekday}; корректная дата.
\end{itemize}

\item[18] \textbf{Високосный год}
Класс \texttt{LeapYearChecker}, метод
\texttt{static LeapResult check(int year)}.
Sealed-класс \texttt{LeapResult}:
\begin{itemize}
\item \texttt{NonPositiveYear} — содержит \texttt{int year}; \(year \leq 0\).
\item \texttt{LeapYear} — содержит \texttt{int year}; делится на 4, но не на 100, либо делится на 400.
\item \texttt{CommonYear} — содержит \texttt{int year}; иначе.
\end{itemize}

\item[19] \textbf{Сумма арифметической прогрессии}
Класс \texttt{ArithmeticProgression}, метод
\texttt{static SumResult sum(int n, double first, double diff)}.
Sealed-класс \texttt{SumResult}:
\begin{itemize}
\item \texttt{NegativeTermCount} — содержит \texttt{int n}; \(n < 0\).
\item \texttt{ZeroTerms} — \(n = 0\).
\item \texttt{ValidSum} — содержит \texttt{int n, double sum}; \(n > 0\).
\end{itemize}

\item[20] \textbf{Проверка возможности построить треугольник}
Класс \texttt{TriangleFeasibility}, метод
\texttt{static FeasibilityResult check(double a, double b, double c)}.
Sealed-класс \texttt{FeasibilityResult}:
\begin{itemize}
\item \texttt{NonPositiveLength} — содержит \texttt{double a, b, c}; стороны \(\leq 0\).
\item \texttt{CannotFormTriangle} — содержит \texttt{double a, b, c}; нарушено неравенство треугольника.
\item \texttt{CanFormTriangle} — содержит \texttt{double a, b, c}; \(a+b>c\), \(a+c>b\), \(b+c>a\).
\end{itemize}

\item[21] \textbf{Цилиндр: объём и площадь поверхности}
Класс \texttt{CylinderCalculator}, метод
\texttt{static CylinderResult compute(double r, double h)}.
Sealed-класс \texttt{CylinderResult}:
\begin{itemize}
\item \texttt{InvalidInput} — содержит \texttt{double r, h}; \(r \leq 0\) или \(h \leq 0\).
\item \texttt{Metrics} — содержит \texttt{double volume, surfaceArea}; \(V = \pi r^2 h\), \(S = 2\pi r(r + h)\).
\end{itemize}

\item[22] \textbf{Пересечение двух отрезков}
Класс \texttt{SegmentIntersection}, метод
\texttt{static IntersectionResult intersect(Point a1, Point a2, Point b1, Point b2)}.
Sealed-класс \texttt{IntersectionResult}:
\begin{itemize}
\item \texttt{NoIntersection} — отрезки не пересекаются.
\item \texttt{PointIntersection} — содержит \texttt{Point p}; пересечение в одной точке.
\item \texttt{Overlap} — содержит \texttt{Point start, Point end}; общий отрезок.
\end{itemize}

\item[23] \textbf{Параллелограмм по четырём точкам}
Класс \texttt{ParallelogramChecker}, метод
\texttt{static ParallelogramResult check(Point p1, Point p2, Point p3, Point p4)}.
Sealed-класс \texttt{ParallelogramResult}:
\begin{itemize}
\item \texttt{Degenerate} — содержит \texttt{Point[] points}; точки вырождены.
\item \texttt{NotParallelogram} — содержит \texttt{Point[] points}; не параллелограмм.
\item \texttt{IsParallelogram} — содержит \texttt{Point[] points}; параллелограмм.
\end{itemize}

\item[24] \textbf{Показательное уравнение \(a^x = b\)}
Класс \texttt{ExponentialEquation}, метод
\texttt{static ExpResult solve(double a, double b)}.
Sealed-класс \texttt{ExpResult}:
\begin{itemize}
\item \texttt{InvalidBase} — содержит \texttt{double a}; \(a \leq 0\).
\item \texttt{NoSolution} — содержит \texttt{double a, double b}; \(a = 1, b \neq 1\).
\item \texttt{InvalidArgument} — содержит \texttt{double b}; \(a > 0, a \neq 1, b \leq 0\).
\item \texttt{InfiniteSolutions} — содержит \texttt{double a, double b}; \(a = 1, b = 1\).
\item \texttt{UniqueSolution} — содержит \texttt{double x}; \(a > 0, a \neq 1, b > 0\).
\end{itemize}

\item[25] \textbf{Анализатор сетевых адресов}
Класс \texttt{NetworkAnalyzer}, метод
\texttt{static AnalysisResult analyze(String address)}.
Sealed-класс \texttt{AnalysisResult}:
\begin{itemize}
\item \texttt{ValidIPv4} — содержит массив 4 байтов
\item \texttt{ValidIPv6} — содержит массив 6 байтов
\item \texttt{InvalidAddress} — содержит \texttt{String error}
\item \texttt{ReservedAddress} — содержит \texttt{String type} (например, "private", "loopback")
\end{itemize}
\end{enumerate}


\section{Семинар 7 (многопоточность)}

\begin{enumerate}
\item[1] Реализуйте потокобезопасный класс \texttt{Counter}, поддерживающий операции \texttt{increment(int value)} (увеличение счётчика), \texttt{decrement(int value)} (уменьшение счётчика, только если результат не станет отрицательным) и \texttt{getValue()}. В методе \texttt{main} создайте один экземпляр с начальным значением~500, запустите 10~потоков: 5~из них по 100~раз вызывают \texttt{increment(5)}, остальные 5 — \texttt{decrement(5)}. После завершения всех потоков выведите итоговое значение. Оно должно быть равно~500.

\item[2] Создайте потокобезопасный класс \texttt{SafeWallet} с методами \texttt{addMoney(int amount)}, \texttt{spendMoney(int amount)} (возвращает \texttt{true}, если хватает средств) и \texttt{getBalance()}. В методе \texttt{main} инициализируйте кошелёк с 2000~единицами, запустите 10~потоков: 5~потоков по 80~раз добавляют по~15, 5~потоков по 80~раз тратят по~15. После завершения выведите баланс — он должен быть равен~2000.

\item[3] Напишите потокобезопасный класс \texttt{ScoreBoard} с методами \texttt{addPoints(int points)}, \texttt{removePoints(int points)} (возвращает \texttt{false}, если недостаточно очков) и \texttt{getScore()}. В методе \texttt{main} создайте объект с начальным счётом~0, запустите 10~потоков: 5~потоков по 120~раз добавляют по~8 очков, 5~потоков по 120~раз убирают по~8. Итоговый счёт должен быть равен~0.

\item[4] Реализуйте потокобезопасный класс \texttt{SafeAccount} с методами \texttt{topUp(int sum)}, \texttt{pay(int sum)} (возвращает \texttt{true}, если оплата возможна) и \texttt{getAmount()}. В методе \texttt{main} создайте счёт с 1500, запустите 10~потоков: 5~потоков по 90~раз пополняют на~20, 5~потоков по 90~раз оплачивают по~20. Итоговый баланс должен быть равен~1500.

\item[5] Создайте потокобезопасный класс \texttt{EnergyMeter} с методами \texttt{charge(int units)}, \texttt{consume(int units)} (возвращает \texttt{true}, если энергии хватает) и \texttt{getLevel()}. В методе \texttt{main} начальный уровень — 1000. Запустите 10~потоков: 5~потоков по 100~раз заряжают на~10, 5~потоков по 100~раз потребляют по~10. Итоговый уровень должен быть равен~1000.

\item[6] Напишите потокобезопасный класс \texttt{SafeStock} с методами \texttt{restock(int items)}, \texttt{sell(int items)} (возвращает \texttt{true}, если товар есть в наличии) и \texttt{getInventory()}. В методе \texttt{main} начальный запас — 800. Запустите 10~потоков: 5~потоков по 70~раз добавляют по~25, 5~потоков по 70~раз продают по~25. Итоговый запас должен быть равен~800.

\item[7] Реализуйте потокобезопасный класс \texttt{FuelTank} с методами \texttt{refill(int liters)}, \texttt{use(int liters)} (возвращает \texttt{true}, если топлива достаточно) и \texttt{getFuel()}. В методе \texttt{main} начальный объём — 1200. Запустите 10~потоков: 5~потоков по 60~раз доливают по~30, 5~потоков по 60~раз расходуют по~30. Итоговый объём должен быть равен~1200.

\item[8] Создайте потокобезопасный класс \texttt{SafePoints} с методами \texttt{earn(int points)}, \texttt{spend(int points)} (возвращает \texttt{true}, если хватает) и \texttt{getTotal()}. В методе \texttt{main} начальное значение — 0. Запустите 10~потоков: 5~потоков по 150~раз зарабатывают по~4, 5~потоков по 150~раз тратят по~4. Итоговое значение должно быть равно~0.

\item[9] Напишите потокобезопасный класс \texttt{WaterReservoir} с методами \texttt{addWater(int liters)}, \texttt{drain(int liters)} (возвращает \texttt{true}, если воды достаточно) и \texttt{getVolume()}. В методе \texttt{main} начальный объём — 2000. Запустите 10~потоков: 5~потоков по 50~раз добавляют по~40, 5~потоков по 50~раз сливают по~40. Итоговый объём должен быть равен~2000.

\item[10] Реализуйте потокобезопасный класс \texttt{SafeBalance} с методами \texttt{credit(int amount)}, \texttt{debit(int amount)} (возвращает \texttt{true}, если баланс не уйдёт в минус) и \texttt{getBalance()}. В методе \texttt{main} начальный баланс — 750. Запустите 10~потоков: 5~потоков по 100~раз зачисляют по~12, 5~потоков по 100~раз списывают по~12. Итоговый баланс должен быть равен~750.

\item[11] Создайте потокобезопасный класс \texttt{TokenBucket} с методами \texttt{addTokens(int n)}, \texttt{useTokens(int n)} (возвращает \texttt{true}, если токенов хватает) и \texttt{getTokenCount()}. В методе \texttt{main} начальное количество — 0. Запустите 10~потоков: 5~потоков по 200~раз добавляют по~3, 5~потоков по 200~раз используют по~3. Итоговое количество должно быть равно~0.

\item[12] Напишите потокобезопасный класс \texttt{SafeInventory} с методами \texttt{supply(int units)}, \texttt{dispatch(int units)} (возвращает \texttt{true}, если есть что отправлять) и \texttt{getStock()}. В методе \texttt{main} начальный запас — 1000. Запустите 10~потоков: 5~потоков по 80~раз поставляют по~25, 5~потоков по 80~раз отгружают по~25. Итоговый запас должен быть равен~1000.

\item[13] Реализуйте потокобезопасный класс \texttt{Battery} с методами \texttt{charge(int percent)}, \texttt{discharge(int percent)} (возвращает \texttt{true}, если заряда хватает) и \texttt{getChargeLevel()}. В методе \texttt{main} начальный уровень — 500. Запустите 10~потоков: 5~потоков по 100~раз заряжают на~5, 5~потоков по 100~раз разряжают на~5. Итоговый уровень должен быть равен~500.

\item[14] Создайте потокобезопасный класс \texttt{SafeCurrency} с методами \texttt{deposit(int coins)}, \texttt{withdraw(int coins)} (возвращает \texttt{true}, если достаточно монет) и \texttt{getCoins()}. В методе \texttt{main} начальное количество — 1800. Запустите 10~потоков: 5~потоков по 60~раз кладут по~50, 5~потоков по 60~раз берут по~50. Итоговое количество должно быть равно~1800.

\item[15] Напишите потокобезопасный класс \texttt{ResourcePool} с методами \texttt{allocate(int units)} (возвращает \texttt{true}, если ресурсов хватает для выделения), \texttt{release(int units)} и \texttt{getAvailable()}. В методе \texttt{main} начальный объём — 1000. Запустите 10~потоков: 5~потоков по 90~раз освобождают по~20 (увеличивают доступный объём), 5~потоков по 90~раз выделяют по~20 (уменьшают объём, только если хватает). Итоговый объём должен быть равен~1000.

\item[16] Реализуйте потокобезопасный класс \texttt{SafeCredit} с методами \texttt{repay(int amount)} (увеличивает доступный лимит), \texttt{borrow(int amount)} (возвращает \texttt{true}, если лимит позволяет) и \texttt{getAvailable()}. В методе \texttt{main} начальный доступный лимит — 2000. Запустите 10~потоков: 5~потоков по 70~раз возвращают по~30, 5~потоков по 70~раз берут по~30. Итоговый лимит должен быть равен~2000.

\item[17] Создайте потокобезопасный класс \texttt{TicketCounter} с методами \texttt{printTickets(int n)}, \texttt{sellTickets(int n)} (возвращает \texttt{true}, если билеты есть) и \texttt{getAvailableTickets()}. В методе \texttt{main} начальное количество — 1500. Запустите 10~потоков: 5~потоков по 50~раз печатают по~60, 5~потоков по 50~раз продают по~60. Итоговое количество должно быть равно~1500.

\item[18] Напишите потокобезопасный класс \texttt{SafeCapacity} с методами \texttt{load(int units)}, \texttt{unload(int units)} (возвращает \texttt{true}, если загружено достаточно для выгрузки) и \texttt{getCurrentLoad()}. В методе \texttt{main} начальная загрузка — 900. Запустите 10~потоков: 5~потоков по 100~раз загружают по~9, 5~потоков по 100~раз выгружают по~9. Итоговая загрузка должна быть равна~900.

\item[19] Реализуйте потокобезопасный класс \texttt{DataQuota} с методами \texttt{addQuota(int mb)}, \texttt{useQuota(int mb)} (возвращает \texttt{true}, если квота не превышена) и \texttt{getRemaining()}. В методе \texttt{main} начальная квота — 2500. Запустите 10~потоков: 5~потоков по 40~раз добавляют по~100, 5~потоков по 40~раз используют по~100. Итоговая квота должна быть равна~2500.

\item[20] Создайте потокобезопасный класс \texttt{SafeStorage} с методами \texttt{store(int items)}, \texttt{retrieve(int items)} (возвращает \texttt{true}, если предметы есть) и \texttt{getItemCount()}. В методе \texttt{main} начальное количество — 600. Запустите 10~потоков: 5~потоков по 100~раз складируют по~14, 5~потоков по 100~раз извлекают по~14. Итоговое количество должно быть равно~600.

\item[21] Напишите потокобезопасный класс \texttt{PowerBank} с методами \texttt{recharge(int units)}, \texttt{supply(int units)} (возвращает \texttt{true}, если энергии хватает) и \texttt{getEnergy()}. В методе \texttt{main} начальный уровень — 1100. Запустите 10~потоков: 5~потоков по 80~раз заряжают на~25, 5~потоков по 80~раз отдают по~25. Итоговый уровень должен быть равен~1100.

\item[22] Реализуйте потокобезопасный класс \texttt{SafeBudget} с методами \texttt{fund(int amount)}, \texttt{expend(int amount)} (возвращает \texttt{true}, если бюджет позволяет) и \texttt{getBalance()}. В методе \texttt{main} начальный бюджет — 3000. Запустите 10~потоков: 5~потоков по 30~раз пополняют на~100, 5~потоков по 30~раз тратят по~100. Итоговый бюджет должен быть равен~3000.

\item[23] Создайте потокобезопасный класс \texttt{CoinPurse} с методами \texttt{insert(int coins)}, \texttt{take(int coins)} (возвращает \texttt{true}, если монеты есть) и \texttt{getCount()}. В методе \texttt{main} начальное количество — 400. Запустите 10~потоков: 5~потоков по 120~раз вкладывают по~5, 5~потоков по 120~раз берут по~5. Итоговое количество должно быть равно~400.

\item[24] Напишите потокобезопасный класс \texttt{SafeReserve} с методами \texttt{increase(int amount)}, \texttt{decrease(int amount)} (возвращает \texttt{true}, если резерв не уходит в минус) и \texttt{getAmount()}. В методе \texttt{main} начальный резерв — 0. Запустите 10~потоков: 5~потоков по 200~раз увеличивают на~6, 5~потоков по 200~раз уменьшают на~6. Итоговый резерв должен быть равен~0.

\item[25] Реализуйте потокобезопасный класс \texttt{SafeFund} с методами \texttt{contribute(int sum)}, \texttt{withdraw(int sum)} (возвращает \texttt{true}, если средств достаточно) и \texttt{getTotal()}. В методе \texttt{main} начальная сумма — 1300. Запустите 10~потоков: 5~потоков по 90~раз вносят по~20, 5~потоков по 90~раз снимают по~20. Итоговая сумма должна быть равна~1300.
\end{enumerate}

\section{Семинар 8 (JavaFX)}

Реализуйте программу с графическим пользовательским интерфейсом с использованием JavaFX.
Как обычно, проверяйте корректность всех исходных данных и сообщайте пользователю о
проблемах.

\begin{enumerate}
   \item Программа решения квадратного уравнения
 \item Программа решения неравенства вида $ax+b>0$
    \item Программа решения неравенства вида $ax+b<0$
 \item Программа решения неравенства вида $ax+b\geqslant 0$
 \item Программа решения неравенства вида $ax+b\leqslant 0$
\item Программа поиска дня недели по числу и месяцу в текущем году
% \item [ПП1-0-3] Программа поиска определителя матрицы $2\times2$
 \item  Программа перевода числа из $10$-ой в $16$-ую, $8$-ую и $2$-ую систем.
 \item  Программа поиска времени, когда окончится интервал. 
 Дано: часы и минуты начала интервала и количество минут, сколько он идет.
 Результат: часы и минуты окончания интервала.
% \item Программа поиска обратной матрицы для матрицы $2\times2$.
  \item Программа поиска обратной матрицы для матрицы $3\times3$.
 \item
 Программа поиска длины интервала. 
 Дано: часы и минуты начала интервала и часы и минуты конца интервала.
 Результат: количество минут в интервале.
 \item
 Программа умножения и деления двух комплексных чисел.
 
% \item[ПП1-0-9]
% Программа нахождения смешанного произведения трех векторов.
 
 \item
 Программа нахождения площади треугольника по координатам вершин.
 
 \item
 Программа нахождения углов треугольника по координатам вершин (проще всего это сделать по теореме косинусов).

  
 \item
 Программа перевода числа из $16$-ой, $8$-ой и $2$-ой системы в $10$-ую систему счисления.
 
 
 \item
 Программа нахождения количества денег на вкладе после окончания его срока по начальному взносу, проценту и сроку в годах. Используйте сложные проценты (начисляются раз в год).
 
 
 \item
 Программа нахождения степени комплексного числа. Исходные данные: действительная, мнимая часть числа и степень. 
 Результат: действительная и мнимая часть результата.
 
 
 \item
 Программа умножения и деления чисел, представленных в виде обыкновенных дробей (состоящих из целой части, числителя и 
 знаменателя). Не забудьте выполнить сокращение дроби и приведение ее к правильному виду.

  \item
 Программа сложения и вычитания чисел, представленных в виде обыкновенных дробей (состоящих из целой части, числителя и 
 знаменателя). Не забудьте выполнить сокращение дроби и приведение ее к правильному виду.

 

 \item
 Программа определения по дате (число и месяц) знака зодиака.
 
 \item
Программа определения по обыкновенной дроби (числителю и знаменателю) периода десятичной дроби.
 
 \item
 Программа перевода комплесного числа из обычной формы в тригонометрическую и наоборот.

 
 \item
 Программа-игра Баше. При реализации этого задания не требуется ничего рисовать, вся информация вводится и выводится в виде
 чисел в обычные элементы управления.
 
 \item
 Программа разложения числа на простые множители.
 
 \item
 Программа нахождения наибольшего общего делителя и наименьшего общего кратного двух натуральных чисел.
 
 
 \item Программа-тест по предмету <<Программирование на Java>>. Создайте программу-тест из 10 вопросов с выбором
вариантов ответов и показом результатов прохождения теста.
\end{enumerate}

\section{Семинар 9 (JavaFX, динамическая генерация)}

  \begin{enumerate}
    \item[1] Пользователь указывает размерность прямоугольной таблицы (строки и столбцы) с помощью \texttt{TextField} или \texttt{Spinner}. После нажатия кнопки «Создать таблицу» на \texttt{GridPane} или \texttt{VBox} динамически создаются соответствующие \texttt{TextField}'ы для ввода чисел. Максимальный размер — $10\times10$. После заполнения и нажатия кнопки «Вычислить» программа рассчитывает:
    \begin{itemize}
        \item Сумму чисел в каждой строке
        \item Сумму чисел в каждом столбце
        \item Общую сумму всех чисел
    \end{itemize}
    Результаты отображаются в \texttt{TextArea} или отдельных \texttt{Label} под таблицей.

    \item[2] Пользователь указывает размерность таблицы (строки и столбцы) через \texttt{TextField}. После нажатия «Создать таблицу» генерируется \texttt{GridPane} с \texttt{TextField}'ами. Максимум $10\times10$ элементов. После заполнения и нажатия «Вычислить» программа:
    \begin{itemize}
        \item Находит минимальный элемент в каждой строке
        \item Определяет максимальное значение среди этих минимальных элементов
    \end{itemize}
    Результат выводится в \texttt{Label}.

    \item[3] Создайте графический редактор на основе \texttt{Pane} или \texttt{Canvas}. Интерфейс содержит:
    \begin{itemize}
        \item Панель инструментов с кнопками выбора фигур (\texttt{Rectangle}, \texttt{Circle}, \texttt{Line}, \texttt{Ellipse})
        \item \texttt{TextField}'ы для ввода координат
        \item Холст для отрисовки
    \end{itemize}
    Пользователь выбирает фигуру, вводит координаты, кликает на холст для размещения. Удаление фигур — двойной клик по фигуре на холсте. Используйте JavaFX Shape API и обработчики событий мыши.

    \item[4] Программа читает файл с описанием расположения \texttt{TextField}'ов (координаты). При запуске:
    \begin{itemize}
        \item Открывается \texttt{FileChooser} для выбора файла
        \item После выбора файла на форме динамически создаются \texttt{TextField}'ы согласно данным из файла
        \item При изменении любого числа в \texttt{TextField}'ах, в \texttt{Label} автоматически обновляется сумма всех введённых чисел
    \end{itemize}
    Формат файла — в удобном для автора-студента формате с координатами полей.

    \item[5] Программа читает файл с описанием \texttt{Label}'ов и интервалов времени. При запуске:
    \begin{itemize}
        \item \texttt{FileChooser} для выбора файла
        \item После загрузки на форме появляются \texttt{Label}'ы с начальными значениями
        \item Для каждого \texttt{Label} создаётся поток, который с указанным 
        интервалом обновляет значение (смотреть пункт ниже)
        \item Каждый \texttt{Label} автоматически увеличивает своё значение на 1 с заданной частотой
    \end{itemize}
    Формат файла выбирается студентом самостоятельно и 
    содержит координаты \texttt{Label}, текст и интервалы в миллисекундах.

    \item[6] Программа читает текстовый файл специального формата:
    \begin{verbatim}
Title:Название1
Описание1
Описание1
Title:Название2
Описание2
    \end{verbatim}
    При запуске:
    \begin{itemize}
        \item \texttt{FileChooser} для выбора файла
        \item Создаётся \texttt{TabPane} с количеством вкладок, равным числу строк «\texttt{Title:}»
        \item Заголовки вкладок — названия из строк «\texttt{Title:}»
        \item Содержимое каждой вкладки — соответствующие описания
    \end{itemize}
    Используйте \texttt{TextArea} или \texttt{Label} для отображения описаний.

    \item[7] Калькулятор для систем счисления от 2 до 36. Интерфейс включает:
    \begin{itemize}
        \item \texttt{ComboBox} для выбора системы счисления
        \item \texttt{TextField} для отображения результата
        \item Динамическая панель с кнопками-цифрами (0–9, A–Z), которая перестраивается при смене системы
        \item Кнопки операций: +, –, *, /, \%
    \end{itemize}
    При смене системы счисления кнопки автоматически создаются/удаляются. Калькулятор поддерживает арифметические операции в выбранной системе. Отрицательные числа не требуются.

    \item[8] Пользователь вводит число $n$ ($2 \leq n \leq 5$) в \texttt{TextField}. После нажатия «Создать» генерируется выражение:
    \begin{itemize}
        \item $n$ \texttt{TextField}'ов для ввода комплексных чисел (формат «\texttt{a+bi}»)
        \item $(n-1)$ \texttt{ComboBox}'ов между ними со знаками операций (+, –, *, /)
    \end{itemize}
    После заполнения и нажатия «Вычислить» программа вычисляет результат слева направо без учёта приоритета операций. Создайте класс \texttt{ComplexNumber} для работы с комплексными числами. Результат отображается в \texttt{Label}.


\item[9] Пользователь вводит число \(n\) (\(2 \leq n \leq 10\)) — количество строк в системе линейных уравнений с двумя неизвестными. После нажатия «Создать» динамически генерируется \(n\) строк, каждая из которых содержит три \texttt{TextField}'а: для коэффициентов \(a_i\), \(b_i\) и свободного члена \(c_i\) (уравнение вида \(a_i x + b_i y = c_i\)). По нажатию «Анализ» программа:
\begin{itemize}
    \item Находит какую-нибудь пару уравнений, имеющих единственное общее решение (если такая есть)
    \item Решает её и выводит \((x, y)\) в \texttt{Label}
    \item Если таких пар нет — выводит соответствующее сообщение
\end{itemize}

\item[10] Пользователь вводит число 
\(n\) (\(1 \leq n \leq 8\)) — количество функций. 
После нажатия «Создать» генерируется \(n\) \texttt{HBox}'ов, каждый из которых содержит:
\begin{itemize}
    \item \texttt{TextField} для формулы функции (только линейные: вида «2*x + 3»)
    \item Два \texttt{Spinner}'а для диапазона \(x\) (от \(-10\) до \(10\))
    \item Кнопку «Построить»
\end{itemize}
При нажатии на любую кнопку «Построить» её функция 
отрисовывается на общем \texttt{Canvas} (точками или линиями).
 Все графики накапливаются. При повторной загрузке формы — холст очищается.

\item[11] Пользователь вводит число \(n\) (\(2 \leq n \leq 12\)) — 
количество векторов в \(\mathbb{R}^3\). После нажатия «Создать» 
генерируется \(n\) групп по три \texttt{TextField}'а (координаты \(x, y, z\)). 
По нажатию «Вычислить»:
\begin{itemize}
    \item Находится вектор с максимальной длиной
    \item Находится любая пара перпендикулярных векторов или выводится, что таких нет
    \item Результаты выводятся в \texttt{Label}'ы
\end{itemize}
Используйте собственный класс \texttt{Vector3D} с методами длины и скалярного произведения.

\item[12] Пользователь вводит число \(n\) (\(3 \leq n \leq 10\)) — 
количество узлов интерполяции. 
После нажатия «Создать» генерируется \(n\) пар \texttt{TextField}'ов для 
координат \((x_i, y_i)\) с уникальными \(x_i\). По нажатию «Построить функцию»:
\begin{itemize}
    \item Программа строит ломаную и отображает его на \texttt{Canvas}
    \item Добавляется \texttt{TextField} для ввода \(x\), и кнопка «Вычислить \(y\)»
    \item При вводе \(x\) в пределах \([x_{\min}, x_{\max}]\) вычисляется и выводится соответствующее \(y\)
\end{itemize}

\item[13] Пользователь вводит число \(n\) (\(2 \leq n \leq 6\)) — количество полиномов. После нажатия «Создать» для каждого полинома генерируется:
\begin{itemize}
    \item \texttt{Spinner} для степени \(d_i\)
    \item После выбора степени — \(d_i + 1\) \texttt{TextField}'ов для коэффициентов \(a_0, a_1, ..., a_{d_i}\)
\end{itemize}
По нажатию «Сложить все»:
\begin{itemize}
    \item Программа складывает все полиномы и выводит результирующий полином 
    в \texttt{TextArea} в формате «$3x^2 + 2x + 1$»
\end{itemize}
Создайте класс \texttt{Polynomial} с методом сложения.

\item[14] Пользователь вводит число \(n\) (\(1 \leq n \leq 10\)) — количество событий. 
После нажатия «Создать» генерируется \(n\) \texttt{HBox}'ов, каждый содержит:
\begin{itemize}
    \item \texttt{TextField} для названия события
    \item \texttt{DatePicker} и \texttt{Spinner} для времени (часы/минуты)
    \item Кнопку «Установить напоминание»
\end{itemize}
При нажатии на кнопку создаётся поток, 
который в заданное время 
показывает \texttt{Alert} с названием события. Все напоминания работают параллельно.
Если соответствующий DatePicker и TextField исчезают, то надо отменить оповещенеи о событии.

\item[15] Пользователь вводит число \(n\) (\(2 \leq n \leq 7\)) — количество матриц. 
После нажатия «Создать» последовательно генерируются панели для каждой матрицы:
\begin{itemize}
    \item Для каждой — \texttt{Spinner} для строк и столбцов (до \(5\times5\))
    \item После подтверждения — \texttt{GridPane} с \texttt{TextField}'ами
\end{itemize}
По нажатию «Перемножить все»:
\begin{itemize}
    \item Программа последовательно перемножает матрицы слева направо (если размеры совместимы)
    \item Результат отображается в новом \texttt{GridPane} под всеми матрицами
    \item При несовместимости — выводится ошибка
\end{itemize}

\item[16] Пользователь вводит число \(n\) (\(3 \leq n \leq 10\)) — количество сторон 
многоугольника. После нажатия «Создать» 
генерируется \(n\) пар \texttt{TextField}'ов для координат вершин. По нажатию «Анализ»:
\begin{itemize}
    \item Проверяется, является ли многоугольник выпуклым (по знаку векторных произведений)
    \item Вычисляется его площадь
    \item Результаты выводятся в \texttt{Label}'ы
\end{itemize}
Опционально: отрисовка на \texttt{Canvas}.

\item[17] Пользователь вводит число \(n\) (\(2 \leq n \leq 8\)) — количество цветов в палитре. 
После нажатия «Создать» генерируется \(n\) строк, каждая из которых содержит:
\begin{itemize}
    \item Три \texttt{Spinner}'а для R, G, B (0–255)
    \item \texttt{Rectangle} (или \texttt{Pane}) для визуализации цвета 
    (обновляется при изменении значений)
    \item Кнопку «Использовать как фон»
\end{itemize}
При нажатии на любую кнопку фон главной панели меняется на выбранный цвет.

\item[18] Пользователь вводит число \(n\) (\(1 \leq n \leq 12\)) — количество временных интервалов. 
После нажатия «Создать» генерируется \(n\) \texttt{HBox}'ов, каждый содержит:
\begin{itemize}
    \item Два \texttt{TextField}'а для временных меток в формате «чч:мм»
    \item \texttt{TextField} для описания
\end{itemize}
По нажатию «Построить расписание»:
\begin{itemize}
    \item Программа проверяет пересечения интервалов
    \item Выводит список конфликтов (если есть) или «Расписание корректно»
    \item Динамически создаёт \texttt{VBox} с 
    цветными полосами-блоками 
    (например, \texttt{Rectangle} + \texttt{Label}) на 
    временной шкале от 00:00 до 24:00
\end{itemize}

\item[19] Пользователь вводит число \(n\) (\(2 \leq n \leq 6\)) — количество 
рациональных чисел. 
После нажатия «Создать» генерируется \(n\) 
пар \texttt{TextField}'ов (числитель/знаменатель). По нажатию «Сортировать»:
\begin{itemize}
    \item Программа сортирует числа по возрастанию
    \item Выводит отсортированный список в \texttt{TextArea} в виде несократимых дробей
\end{itemize}
Используйте собственный класс \texttt{Rational} с методом сравнения.

\item[20] Пользователь вводит число \(n\) (\(3 \leq n \leq 10\)) — 
количество точек на плоскости. После нажатия «Создать» 
генерируется \(n\) пар \texttt{TextField}'ов. По нажатию «Найти оболочку»:
\begin{itemize}
    \item Программа находит выпуклую оболочку методом Джарвиса (см. википедию)
    \item Выводит индексы точек, входящих в оболочку, в \texttt{Label}
    \item Опционально: отрисовка всех точек и оболочки на \texttt{Canvas}
\end{itemize}

\item[21] Пользователь вводит число \(n\) (\(1 \leq n \leq 8\)) — 
количество пользовательских кнопок. После нажатия «Создать» 
генерируется \(n\) \texttt{TextField}'ов для надписей на кнопках и \(n\) 
\texttt{ColorPicker}'ов для фона. По нажатию «Применить»:
\begin{itemize}
    \item Динамически создаётся горизонтальная панель с \(n\) кнопками, 
    каждая с заданной надписью и цветом фона
    \item При нажатии на любую кнопку в \texttt{Label} выводится 
    её надпись и порядковый номер
\end{itemize}

\item[22] Пользователь вводит число \(n\) (\(2 \leq n \leq 10\)) — количество строк 
в текстовом конструкторе. 
После нажатия «Создать» генерируется \(n\) \texttt{HBox}'ов, каждый содержит:
\begin{itemize}
    \item \texttt{TextField} для префикса
    \item \texttt{ComboBox} с типом данных («целое», «вещественное», «слово»)
    \item \texttt{TextField} для суффикса
\end{itemize}
По нажатию «Сгенерировать образцы»:
\begin{itemize}
    \item Для каждой строки создаётся 3 примера строки в формате 
    «префикс + случайное значение + суффикс»
    \item Все образцы выводятся в \texttt{TextArea}
\end{itemize}

\item[23] Пользователь вводит число \(n\) (\(2 \leq n \leq 7\)) — 
количество наборов данных. После нажатия «Создать»:
\begin{itemize}
    \item Для каждого набора: \texttt{TextField} для названия 
    и \texttt{Spinner} для размера \(k_i\) (\(3 \leq k_i \leq 8\))
    \item После подтверждения — для каждого набора 
    генерируется \(k_i\) \texttt{TextField}'ов для чисел
\end{itemize}
По нажатию «Сравнить дисперсии»:
\begin{itemize}
    \item Программа вычисляет выборочную дисперсию каждого набора
    \item Находит набор с наибольшей дисперсией и выводит его название
\end{itemize}


\item[24] Пользователь вводит число \(n\) (\(2 \leq n \leq 8\)) — 
количество критериев фильтрации слов. 
После нажатия «Создать фильтры» динамически 
генерируется \(n\) строк, каждая из которых содержит:
\begin{itemize}
    \item \texttt{ComboBox} с выбором типа критерия:  
    «Начинается с», «Оканчивается на», «Содержит подстроку», «Длина ровно»
    \item В зависимости от выбора:
    \begin{itemize}
        \item Для первых трёх — \texttt{TextField} для ввода строки
        \item Для «Длина ровно» — \texttt{Spinner} (от 1 до 20)
    \end{itemize}
\end{itemize}
Ниже размещается \texttt{TextArea} для ввода списка слов 
(по одному на строку). По нажатию «Применить фильтры»:
\begin{itemize}
    \item Для каждого критерия динамически создаётся \texttt{Label} вида:  
    «Критерий 1: 5 слов прошли фильтр»
    \item Под ними — \texttt{TextArea} с объединённым результатом:  
    словами, которые прошли \textbf{все} фильтры одновременно
\end{itemize}

\item[25] Пользователь вводит число \(n\) (\(2 \leq n \leq 6\)) — количество 
дробно-линейных функций. После нажатия «Создать» для каждой функции 
генерируется 4 \texttt{TextField}'а для коэффициентов \(a, b, c, d\) 
(функция вида \(f(x) = \frac{ax + b}{cx + d}\)). По нажатию «Композиция»:
\begin{itemize}
    \item Программа последовательно компонует функции: 
    \(f_1 \circ f_2 \circ \dots \circ f_n\)
    \item Выводит результирующую функцию в виде коэффициентов и формулы в \texttt{Label}
\end{itemize}
Используйте собственный класс \texttt{MobiusTransform} с методом композиции.

  \end{enumerate}

\section{Семинар 10 (JavaFX, анимация и физика)}

\begin{enumerate}
  \item Пользователь выбирает начальную скорость двух мячей и направление их движения (на бильярдном столе). Программа показывает замедленный ``мультфильм'' движения мячей с учётом упругого отскока от границ стола, упругого столкновения друг с другом и силы сопротивления среды $\vec{F}_c = -\alpha \vec{v}$, где $\alpha$ также задаётся пользователем. Лунки учитывать не требуется.

  \item Пользователь задаёт координаты источника света и направление испускания луча, а также координаты левого верхнего и правого нижнего углов прямоугольника, соответствующего ёмкости с веществом, имеющим показатель преломления $\alpha$ (также вводится). Границы рисунка считаются идеально отражающими зеркалами. Программа отображает траекторию луча света в чрезвычайно замедленной ``съёмке'' с сохранением следа на экране.

  \item Пользователь задаёт координаты источника света (луч направлен перпендикулярно линзе) и координаты начала и конца отрезка, символизирующего тонкую линзу с фокусным расстоянием $f$ (также вводится). Границы рисунка — идеально отражающие зеркала. Программа показывает замедленное движение луча света от источника с сохранением его следа.

  \item Пользователь выбирает начальную скорость и направление движения двух мячей на бильярдном столе. Программа анимирует их движение с учётом упругих отражений от границ стола, упругого столкновения между собой, а также отскоков от дополнительного прямоугольного препятствия, задаваемого координатами левого верхнего и правого нижнего углов. Лунки не учитываются.

  \item Пользователь задаёт координаты и направление источника света, а также координаты трёх вершин треугольника, соответствующего ёмкости с веществом показателя преломления $\alpha$ (вводится). Границы рисунка — идеальные зеркала. Программа показывает замедленное движение луча света от источника с сохранением его следа.

  \item Пользователь выбирает начальную скорость и направление движения двух мячей на бильярдном столе. Программа моделирует их движение с учётом упругих отражений от границ стола, столкновения между собой и отскоков от заданного треугольного препятствия (координаты трёх вершин). Лунки не учитываются.

  \item Пользователь задаёт начальную скорость и направление движения одного мяча на бильярдном столе. Дополнительно задаётся движущийся параллелепипед (прямоугольник) координатами левого верхнего и правого нижнего углов и его скорость. Параллелепипед движется горизонтально: слева направо, отражается от правой стенки стола и движется в обратную сторону, и так далее. Программа показывает замедленную анимацию упругих отскоков мяча от границ стола и от движущегося параллелепипеда.

  \item Аналогично предыдущему заданию, но параллелепипед движется вертикально: сверху вниз, отражается от нижней границы стола и движется вверх, повторяя цикл. Анимация учитывает упругие отскоки от стенок стола и от движущегося объекта.

  \item Пользователь задаёт координаты источника света, направление луча и координаты концов отрезка, соответствующего идеальному зеркалу. Границы рисунка также являются идеальными зеркалами. Программа отображает замедленное движение луча света с сохранением следа его траектории.

  \item Пользователь задаёт начальную скорость шайбы и скорость её вращения. Программа демонстрирует движение шайбы по прямоугольному полю с упругим отражением от границ. Сила сопротивления пропорциональна линейной скорости, момент сил трения так же пропорциональна угловой скорости. На шайбе отображаются два перпендикулярных отрезка для визуализации вращения.

  \item Пользователь задаёт радиусы двух дисков, ширину зубцов и расстояние между ними (единые для обоих дисков). Программа рисует диски и цепь, их соединяющую. Первый диск вращается с заданной угловой скоростью, передавая движение второму через цепь.

  \item Пользователь задаёт радиусы двух дисков и положение одного зубца на каждом. Зубцы соединены нитью, перекинутой через неподвижный блок. Первый диск вращается с заданной скоростью в пределах углового интервала, при котором нить остаётся натянутой. При достижении границы интервала направление вращения мгновенно меняется. Если нить не обрывается ни при каком положении, диск вращается непрерывно.

  \item Моделирование движения двух планет. Пользователь задаёт начальные координаты и векторы скоростей двух шаров. На каждый шар действует сила притяжения к другому, равная $\dfrac{k}{r^2}$, где $k$ — параметр, зависящий от шара, а $r$ — расстояние между ними. Движение прекращается при столкновении шаров. Расчёт ведётся пошагово: на каждом кванте времени движение считается равноускоренным и прямолинейным.

  \item Моделирование движения спутника. Один шар неподвижен (центр масс), второй — спутник с заданной начальной скоростью. На спутник действует сила притяжения к центру: $\dfrac{k}{r^2}$, где $k$ задаётся пользователем, $r$ — расстояние до центра. При столкновении движение останавливается. Если нажата клавиша пробел, спутнику сообщается дополнительное ускорение в направлении его текущей скорости (величина ускорения задаётся заранее). Расчёт — пошаговый, с равноускоренным движением на каждом шаге.

  \item Моделирование движения двух спутников вокруг третьего (неподвижного) центрального тела. Пользователь задаёт начальные координаты и скорости двух спутников. На каждый из них действует сила притяжения к центральному телу: $\dfrac{k_i}{r_i^2}$, где $k_i$ — параметр для $i$-го спутника, $r_i$ — расстояние до центра. Движение прекращается при любом контакте между шарами. Расчёт пошаговый с равноускоренным движением на каждом интервале.

  \item На экране изображены две наклонные плоскости, соприкасающиеся в нижней точке под углами $\alpha$ и $\beta$ к горизонту (углы задаются). Шар помещается в начальную точку на одной из плоскостей и движется под действием силы тяжести и сопротивления воздуха. Сопротивление моделируется умножением скорости на коэффициент $k < 1$ на каждом шаге. Масса шара также задаётся. На шаре отображаются две перпендикулярные линии для визуализации вращения.

  \item Пользователь задаёт начальную скорость и направление движения двух мячей на бильярдном столе. Программа анимирует их движение с учётом упругих отражений от границ стола, взаимного столкновения и отскоков от выпуклого четырёхугольного препятствия, заданного координатами четырёх вершин. Лунки не учитываются.

  \item Пользователь задаёт начальную скорость и направление движения одного мяча 
  на бильярдном столе, а также координаты центра и радиус круглого препятствия. 
  Программа показывает замедленную анимацию движения мяча с учётом упругого отскока 
  от границ стола и от круглого препятствия. Лунки не учитываются.

  \item Пользователь задаёт координаты источника света, направление луча и 
  координаты центра с радиусом круглой области, заполненной веществом с показателем 
  преломления $\alpha$ (вводится). Границы рисунка — идеальные зеркала. 
  Программа отображает траекторию луча света в замедленной съёмке с сохранением следа, 
  включая преломление на границе круга и отражения от краёв экрана.

  \item Пользователь задаёт координаты источника света, направление луча и 
  координаты двух отдельных отрезков (идеальных зеркал). Границы рисунка 
  также являются идеальными зеркалами. Программа визуализирует замедленное распространение 
  луча с сохранением полной траектории, включая многократные отражения от всех зеркал.

  \item Пользователь задаёт начальную скорость и положение одного мяча, а также 
  координаты и скорость равномерно движущейся точки-цели (например, маленького круга). 
  На мяч действует сила притяжения к движущейся цели, пропорциональная $1/r^2$ 
  ($r$ — расстояние до цели). Программа показывает замедленную анимацию 
  движения мяча под действием этой силы и упругих отражений от границ стола.

  \item Пользователь задаёт начальную скорость и направление движения двух мячей на бильярдном столе. Программа моделирует их движение с учётом упругих отражений от границ, упругого столкновения между собой и силы сопротивления среды $\vec{F}_c = -\alpha \vec{v}$. Дополнительно, при каждом отскоке от стенки мяч оставляет временный след, исчезающий через фиксированное время.

  \item Пользователь задаёт координаты источника света, направление луча и координаты прямоугольной области, заполненной веществом с показателем преломления $\alpha$. Границы рисунка — идеальные зеркала. Программа отображает замедленную траекторию луча с сохранением следа, включая преломления на границах прямоугольника и отражения от краёв экрана.

  \item Пользователь задаёт начальную скорость и направление движения одного мяча на бильярдном столе, а также координаты неподвижного эллиптического препятствия, заданного центром, длинами полуосей $a$, $b$ и углом поворота $\theta$. Программа показывает замедленную анимацию движения мяча с учётом упругого отскока от границ стола и от эллипса. Лунки не учитываются.

  \item Пользователь задаёт начальную скорость и направление движения шайбы на прямоугольном поле. На шайбу действует сила сопротивления $\vec{F}_c = -\alpha \vec{v}$. Шайба упруго отражается от границ. Для визуализации вращения на шайбе отображаются две перпендикулярные линии, которые пассивно поворачиваются пропорционально пройденному пути (угол поворота равен $k \cdot s$, где $s$ — пройденное расстояние, $k$ — параметр, задаваемый пользователем), но вращение не влияет на динамику движения.

 
\end{enumerate}

\section{Семинар 11 (JavaFX, CRUD)}

Создайте приложение с использованием JavaFX с полной CRUD-функциональностью, а также
с возможностью фильтрации по любому полю. Для хранения используйте файл SQlite. 

Проверяйте корректность всех входных данных, проверяйте ошибки при работе с базой данных
и оповещайте об этом пользователя, работу проводите таким образом, чтобы нельзя было
осуществить SQL-инъекции.

    \begin{enumerate}
	\item База данных студентов группы. Поля: фамилия, имя, отчество, пол, возраст. 
	\item База данных расходов семьи. Поля: товар, стоимость, количество, дата.
	\item База данных загрузки аудиторий. Поля: дата и время, начала, дата и время конца, аудитория, преподаватель. 
	\item База данных учета доходов и расходов предпринимателя. Поля: дата, тип операции (доход/расход), объем операции, описание, 
корреспондент. 
	\item База данных велоклуба. Поля: ФИО, тип велосипеда (MTB и др.), стаж участия в велоклубе.
	\item База данных рейсов авиакомпании. Поля: дата и время вылета, аэропорт вылета, аэропорт прилета, дата и время прилета, 
марка самолета.
	\item База данных автобусных маршрутов. Поля: номер маршрута, номер парка, времена начала и окончания движения,
длина маршрута в км. 
	\item База данных электричек. Поля: вокзал, номер поезда, количество вагонов, тип (экспресс/обычный/спутник).
	\item База данных товаров Интернет-магазина. Поля: название товара, категория, цена товара, описание товара. 
	\item База заказов Интернет-магазина. Поля: ФИО заказчика, стоимость заказа, скидка (в процентах), адрес доставки. 
	\item База данных выборов. Поля: участок, кандидат, количество голосов.
	\item База данных практических работ. Поля: практическая работа, студент, номер варианта, номер уровня, 
дата сдачи, оценка. 
	\item База данных операторов и телеканалов. Поля: Название, тип (спутник, кабель, Интернет), охват (кол-во миллионов домохозяйств), минимальная
стоимость подписки. 
	\item База данных тарифных планов оператора. Поля: название, тип вещания (обычный/HD), флаг общедоступности. 
	\item База данных незаконно огороженных берегов. Поля: водный объект, регион, GPS-координаты, длина недоступного участка берега, дата фиксации нарушения.
	\item База данных временного прекращения движения в метро. Поля: дата и время начала прекращения
движения, дата и время окончания прекращения движения, станция, станция (от какой до какой станции прекращено движение).
	\item База данных проката фильмов. Поля: дата, время, кинотеатр, фильм, номер зала, тип сеанса (3D/Imax/обычный).
	\item База данных эвакуированных автомобилей. Поля: улица, автостоянка, GPS-координаты, 
тип нарушения (стоянка на проезжей части в месте запрета, стояна на тротуаре, стоянка на газоне), 
номер автомобиля, тип автомобиля (легковой/грузовой малой тонажности/грузовой большой
тонажности). 
	\item База данных средних специальных учебных учреждений. Поля: название, адрес, тип подчинения (федеральный/региональный), 
год основания, номер лицензии, номер аккредитации, дата окончания действия аккредитации. 
	\item База данных поселков. Поля: название, девелопер, площадь, количество жителей.
	\item База данных сухопутной военной техники. Поля: название, модель, разработчик, предприятие, стоимость, тип. 
	\item База данных деревьев в городе. Поля: GPS-координаты, вид дерева, округ, год посадки. 
	\item База данных футбольных матчей. Поля: дата, команда, команда, счет, место проведения. 
	\item База данных обращений жителей. Поля: дата, время, объект, заявитель, содержание обращения (до 255 символов), 
дата ответа, ответ на обращение (до 255 символов).
	\item База данных студентов колледжа. Поля: ФИО, группа, признак бюджетности, 
стипендия (нет/обычная/повышенная), флаг наличия социальной стипендии, дата рождения.
\end{enumerate}

\section{Семинар 12 (Spring Boot, REST API)}

Разработайте с использованием Spring boot REST API сервис в соответствии с вариантом 
предыдущего семинара

\section{Семинар 13 (JavaFX + REST API)}

Модифицируйте программу, разработанную на предпредыдущем семинаре с целью полной 
синхронизации локальных данных и данных на сервере, разработанном на предыдущем семинаре

\section{Семинар 14 (JWT)}

Реализуйте функционал регистрации, аутентификации и авторизации на REST API сервисе,
реализованном на предпредыдущем семинаре, реализуйте функционал регистрации и аутентификации
в программе, реализованной на предыдущем семинаре. 

В итоге каждый пользователь должен иметь доступ только к своим объектам в базе данных,
работа сессий должна поддерживаться посредством JWT.

\section{Семинары 15\&16 (итоги)}

В ходе семинаров предполагается прием и защита работ, закрытие <<долгов>>, 
а также проведение заключительного письменного опроса по курсу.

\end{document}